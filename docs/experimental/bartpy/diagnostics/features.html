<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import Counter
from typing import List, Mapping, Union, Optional

import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib import pyplot as plt

from ..runner import run_models
from ..sklearnmodel import SklearnModel

ImportanceMap = Mapping[int, float]
ImportanceDistributionMap = Mapping[int, List[float]]


def feature_split_proportions(model: SklearnModel, columns: Optional[List[int]]=None) -&gt; Mapping[int, float]:

    split_variables = []
    for sample in model.model_samples:
        for tree in sample.trees:
            for node in tree.nodes:
                splitting_var = node.split.splitting_variable
                split_variables.append(splitting_var)
    counter = Counter(split_variables)
    if columns is None:
        columns = sorted(list([x for x in counter.keys() if x is not None]))

    proportions = {}
    for column in columns:
        if column in counter.keys():
            proportions[column] = counter[column] / len(split_variables)
        else:
            proportions[column] = 0.0

    return proportions


def plot_feature_split_proportions(model: SklearnModel, ax=None):
    if ax is None:
        _, ax = plt.subplots(1, 1)
    proportions = feature_split_proportions(model)

    y_pos = np.arange(len(proportions))
    name, count = list(proportions.keys()), list(proportions.values())
    props = pd.DataFrame({&#34;name&#34;: name, &#34;counts&#34;: count}).sort_values(&#34;name&#34;, ascending=True)
    plt.barh(y_pos, props.counts, align=&#39;center&#39;, alpha=0.5)
    plt.yticks(y_pos, props.name)
    plt.xlabel(&#39;Proportion of all splits&#39;)
    plt.ylabel(&#39;Feature&#39;)
    plt.title(&#39;Proportion of Splits Made on Each Variable&#39;)
    return ax


def null_feature_split_proportions_distribution(model: SklearnModel,
                                                X: Union[pd.DataFrame, np.ndarray],
                                                y: np.ndarray,
                                                n_permutations: int=10) -&gt; Mapping[int, List[float]]:
    &#34;&#34;&#34;
    Calculate a null distribution of proportion of splits on each variable in X

    Works by randomly permuting y to remove any true dependence of y on X and calculating feature importance

    Parameters
    ----------
    model: SklearnModel
        Model specification to work with
    X: np.ndarray
        Covariate matrix
    y: np.ndarray
        Target data
    n_permutations: int
        How many permutations to run
        The higher the number of permutations, the more accurate the null distribution, but the longer it will take to run
    Returns
    -------
    Mapping[int, List[float]]
        A list of inclusion proportions for each variable in X
    &#34;&#34;&#34;

    inclusion_dict = {x: [] for x in range(X.shape[1])}

    y_s = [np.random.permutation(y) for _ in range(n_permutations)]
    X_s = [X for _ in y_s]

    fit_models = run_models(model, X_s, y_s)

    for model in fit_models:
        splits_run = feature_split_proportions(model, list(range(X.shape[1])))
        for key, value in splits_run.items():
            inclusion_dict[key].append(value)

    return inclusion_dict


def plot_null_feature_importance_distributions(null_distributions: Mapping[int, List[float]], ax=None) -&gt; None:
    if ax is None:
        _, ax = plt.subplots(1, 1)
    df = pd.DataFrame(null_distributions)
    df = pd.DataFrame(df.unstack()).reset_index().drop(&#34;level_1&#34;, axis=1)
    df.columns = [&#34;variable&#34;, &#34;p&#34;]
    sns.boxplot(x=&#34;variable&#34;, y=&#34;p&#34;, data=df, ax=ax)
    ax.set_title(&#34;Null Feature Importance Distribution&#34;)
    return ax


def local_thresholds(null_distributions: ImportanceDistributionMap, percentile: float) -&gt; Mapping[int, float]:
    &#34;&#34;&#34;
    Calculate the required proportion of splits to be selected by variable

    Creates a null distribution for each variable based on the % of splits including that variable in each of the permuted models

    Each variable has its own threshold that is independent of the other variables

    Note - this is significantly less stringent than the global threshold

    Parameters
    ----------
    null_distributions: ImportanceDistributionMap
        A mapping from variable to distribution of split inclusion proportions under the null
    percentile: float
        The percentile of the null distribution to use as a cutoff.
        The closer to 1.0, the more stringent the threshold

    Returns
    -------
    Mapping[int, float]
        A lookup from column to % inclusion threshold
    &#34;&#34;&#34;
    return {feature: np.percentile(null_distributions[feature], percentile) for feature in null_distributions}


def global_thresholds(null_distributions: ImportanceDistributionMap, percentile: float) -&gt; Mapping[int, float]:
    &#34;&#34;&#34;
    Calculate the required proportion of splits to be selected by variable

    Creates a distribution of the _highest_ inclusion percentage of any variable in each of the permuted models
    Threshold is set as a percentile of this distribution

    All variables have the same threshold

    Note that this is significantly more stringent than the local threshold

    Parameters
    ----------
    null_distributions: ImportanceDistributionMap
        A mapping from variable to distribution of split inclusion proportions under the null
    percentile: float
        The percentile of the null distribution to use as a cutoff.
        The closer to 1.0, the more stringent the threshold

    Returns
    -------
    Mapping[int, float]
        A lookup from column to % inclusion threshold
    &#34;&#34;&#34;
    q_s = []
    df = pd.DataFrame(null_distributions)
    for row in df.iter_rows():
        q_s.append(np.max(row))
    threshold = np.percentile(q_s, percentile)
    return {feature: threshold for feature in null_distributions}


def kept_features(feature_proportions: Mapping[int, float], thresholds: Mapping[int, float]) -&gt; List[int]:
    &#34;&#34;&#34;
    Extract the features to keep

    Parameters
    ----------
    feature_proportions: Mapping[int, float]
        Lookup from variable to % of splits in the model that use that variable
    thresholds:  Mapping[int, float]
        Lookup from variable to required % of splits in the model to be kept

    Returns
    -------
    List[int]
        Variable selected for inclusion in the final model
    &#34;&#34;&#34;
    return [x[0] for x in zip(sorted(feature_proportions.keys()), is_kept(feature_proportions, thresholds)) if x[1]]


def is_kept(feature_proportions: Mapping[int, float], thresholds: Mapping[int, float]) -&gt; List[bool]:
    &#34;&#34;&#34;
    Determine whether each variable should be kept after selection

    Parameters
    ----------
    feature_proportions: Mapping[int, float]
        Lookup from variable to % of splits in the model that use that variable
    thresholds:  Mapping[int, float]
        Lookup from variable to required % of splits in the model to be kept

    Returns
    -------
    List[bool]
        An array of length equal to the width of the covariate matrix
        True if the variable should be kept, False otherwise
    &#34;&#34;&#34;
    print(sorted(list(feature_proportions.keys())))
    return [feature_proportions[feature] &gt; thresholds[feature] for feature in sorted(list(feature_proportions.keys()))]


def partition_into_passed_and_failed_features(feature_proportions, thresholds):
    kept = kept_features(feature_proportions, thresholds)
    passed_features = {x[0]: x[1] for x in feature_proportions.items() if x[0] in kept}
    failed_features = {x[0]: x[1] for x in feature_proportions.items() if x[0] not in kept}
    return passed_features, failed_features


def plot_feature_proportions_against_thresholds(feature_proportions, thresholds, ax=None):
    if ax is None:
        _, ax = plt.subplots(1, 1)
    passed_features, failed_features = partition_into_passed_and_failed_features(feature_proportions, thresholds)

    ax.bar(thresholds.keys(), [x * 100 for x in thresholds.values()], width=0.01, color=&#34;black&#34;, alpha=0.5)
    ax.scatter(passed_features.keys(), [x * 100 for x in passed_features.values()], c=&#34;g&#34;)
    ax.scatter(failed_features.keys(), [x * 100 for x in failed_features.values()], c=&#34;r&#34;)
    ax.set_title(&#34;Feature Importance Compared to Threshold&#34;)
    ax.set_xlabel(&#34;Feature&#34;)
    ax.set_ylabel(&#34;% Splits&#34;)
    return ax</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="imodels.experimental.bartpy.diagnostics.features.feature_split_proportions"><code class="name flex">
<span>def <span class="ident">feature_split_proportions</span></span>(<span>model:¬†<a title="imodels.experimental.bartpy.sklearnmodel.SklearnModel" href="../sklearnmodel.html#imodels.experimental.bartpy.sklearnmodel.SklearnModel">SklearnModel</a>, columns:¬†Optional[List[int]]¬†=¬†None) ‚Äë>¬†Mapping[int,¬†float]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feature_split_proportions(model: SklearnModel, columns: Optional[List[int]]=None) -&gt; Mapping[int, float]:

    split_variables = []
    for sample in model.model_samples:
        for tree in sample.trees:
            for node in tree.nodes:
                splitting_var = node.split.splitting_variable
                split_variables.append(splitting_var)
    counter = Counter(split_variables)
    if columns is None:
        columns = sorted(list([x for x in counter.keys() if x is not None]))

    proportions = {}
    for column in columns:
        if column in counter.keys():
            proportions[column] = counter[column] / len(split_variables)
        else:
            proportions[column] = 0.0

    return proportions</code></pre>
</details>
</dd>
<dt id="imodels.experimental.bartpy.diagnostics.features.global_thresholds"><code class="name flex">
<span>def <span class="ident">global_thresholds</span></span>(<span>null_distributions:¬†Mapping[int,¬†List[float]], percentile:¬†float) ‚Äë>¬†Mapping[int,¬†float]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the required proportion of splits to be selected by variable</p>
<p>Creates a distribution of the <em>highest</em> inclusion percentage of any variable in each of the permuted models
Threshold is set as a percentile of this distribution</p>
<p>All variables have the same threshold</p>
<p>Note that this is significantly more stringent than the local threshold</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>null_distributions</code></strong> :&ensp;<code>ImportanceDistributionMap</code></dt>
<dd>A mapping from variable to distribution of split inclusion proportions under the null</dd>
<dt><strong><code>percentile</code></strong> :&ensp;<code>float</code></dt>
<dd>The percentile of the null distribution to use as a cutoff.
The closer to 1.0, the more stringent the threshold</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Mapping[int, float]</code></dt>
<dd>A lookup from column to % inclusion threshold</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def global_thresholds(null_distributions: ImportanceDistributionMap, percentile: float) -&gt; Mapping[int, float]:
    &#34;&#34;&#34;
    Calculate the required proportion of splits to be selected by variable

    Creates a distribution of the _highest_ inclusion percentage of any variable in each of the permuted models
    Threshold is set as a percentile of this distribution

    All variables have the same threshold

    Note that this is significantly more stringent than the local threshold

    Parameters
    ----------
    null_distributions: ImportanceDistributionMap
        A mapping from variable to distribution of split inclusion proportions under the null
    percentile: float
        The percentile of the null distribution to use as a cutoff.
        The closer to 1.0, the more stringent the threshold

    Returns
    -------
    Mapping[int, float]
        A lookup from column to % inclusion threshold
    &#34;&#34;&#34;
    q_s = []
    df = pd.DataFrame(null_distributions)
    for row in df.iter_rows():
        q_s.append(np.max(row))
    threshold = np.percentile(q_s, percentile)
    return {feature: threshold for feature in null_distributions}</code></pre>
</details>
</dd>
<dt id="imodels.experimental.bartpy.diagnostics.features.is_kept"><code class="name flex">
<span>def <span class="ident">is_kept</span></span>(<span>feature_proportions:¬†Mapping[int,¬†float], thresholds:¬†Mapping[int,¬†float]) ‚Äë>¬†List[bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Determine whether each variable should be kept after selection</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature_proportions</code></strong> :&ensp;<code>Mapping[int, float]</code></dt>
<dd>Lookup from variable to % of splits in the model that use that variable</dd>
<dt><strong><code>thresholds</code></strong> :&ensp;<code> Mapping[int, float]</code></dt>
<dd>Lookup from variable to required % of splits in the model to be kept</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[bool]</code></dt>
<dd>An array of length equal to the width of the covariate matrix
True if the variable should be kept, False otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_kept(feature_proportions: Mapping[int, float], thresholds: Mapping[int, float]) -&gt; List[bool]:
    &#34;&#34;&#34;
    Determine whether each variable should be kept after selection

    Parameters
    ----------
    feature_proportions: Mapping[int, float]
        Lookup from variable to % of splits in the model that use that variable
    thresholds:  Mapping[int, float]
        Lookup from variable to required % of splits in the model to be kept

    Returns
    -------
    List[bool]
        An array of length equal to the width of the covariate matrix
        True if the variable should be kept, False otherwise
    &#34;&#34;&#34;
    print(sorted(list(feature_proportions.keys())))
    return [feature_proportions[feature] &gt; thresholds[feature] for feature in sorted(list(feature_proportions.keys()))]</code></pre>
</details>
</dd>
<dt id="imodels.experimental.bartpy.diagnostics.features.kept_features"><code class="name flex">
<span>def <span class="ident">kept_features</span></span>(<span>feature_proportions:¬†Mapping[int,¬†float], thresholds:¬†Mapping[int,¬†float]) ‚Äë>¬†List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the features to keep</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature_proportions</code></strong> :&ensp;<code>Mapping[int, float]</code></dt>
<dd>Lookup from variable to % of splits in the model that use that variable</dd>
<dt><strong><code>thresholds</code></strong> :&ensp;<code> Mapping[int, float]</code></dt>
<dd>Lookup from variable to required % of splits in the model to be kept</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[int]</code></dt>
<dd>Variable selected for inclusion in the final model</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kept_features(feature_proportions: Mapping[int, float], thresholds: Mapping[int, float]) -&gt; List[int]:
    &#34;&#34;&#34;
    Extract the features to keep

    Parameters
    ----------
    feature_proportions: Mapping[int, float]
        Lookup from variable to % of splits in the model that use that variable
    thresholds:  Mapping[int, float]
        Lookup from variable to required % of splits in the model to be kept

    Returns
    -------
    List[int]
        Variable selected for inclusion in the final model
    &#34;&#34;&#34;
    return [x[0] for x in zip(sorted(feature_proportions.keys()), is_kept(feature_proportions, thresholds)) if x[1]]</code></pre>
</details>
</dd>
<dt id="imodels.experimental.bartpy.diagnostics.features.local_thresholds"><code class="name flex">
<span>def <span class="ident">local_thresholds</span></span>(<span>null_distributions:¬†Mapping[int,¬†List[float]], percentile:¬†float) ‚Äë>¬†Mapping[int,¬†float]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the required proportion of splits to be selected by variable</p>
<p>Creates a null distribution for each variable based on the % of splits including that variable in each of the permuted models</p>
<p>Each variable has its own threshold that is independent of the other variables</p>
<p>Note - this is significantly less stringent than the global threshold</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>null_distributions</code></strong> :&ensp;<code>ImportanceDistributionMap</code></dt>
<dd>A mapping from variable to distribution of split inclusion proportions under the null</dd>
<dt><strong><code>percentile</code></strong> :&ensp;<code>float</code></dt>
<dd>The percentile of the null distribution to use as a cutoff.
The closer to 1.0, the more stringent the threshold</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Mapping[int, float]</code></dt>
<dd>A lookup from column to % inclusion threshold</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_thresholds(null_distributions: ImportanceDistributionMap, percentile: float) -&gt; Mapping[int, float]:
    &#34;&#34;&#34;
    Calculate the required proportion of splits to be selected by variable

    Creates a null distribution for each variable based on the % of splits including that variable in each of the permuted models

    Each variable has its own threshold that is independent of the other variables

    Note - this is significantly less stringent than the global threshold

    Parameters
    ----------
    null_distributions: ImportanceDistributionMap
        A mapping from variable to distribution of split inclusion proportions under the null
    percentile: float
        The percentile of the null distribution to use as a cutoff.
        The closer to 1.0, the more stringent the threshold

    Returns
    -------
    Mapping[int, float]
        A lookup from column to % inclusion threshold
    &#34;&#34;&#34;
    return {feature: np.percentile(null_distributions[feature], percentile) for feature in null_distributions}</code></pre>
</details>
</dd>
<dt id="imodels.experimental.bartpy.diagnostics.features.null_feature_split_proportions_distribution"><code class="name flex">
<span>def <span class="ident">null_feature_split_proportions_distribution</span></span>(<span>model:¬†<a title="imodels.experimental.bartpy.sklearnmodel.SklearnModel" href="../sklearnmodel.html#imodels.experimental.bartpy.sklearnmodel.SklearnModel">SklearnModel</a>, X:¬†Union[numpy.ndarray,¬†pandas.core.frame.DataFrame], y:¬†numpy.ndarray, n_permutations:¬†int¬†=¬†10) ‚Äë>¬†Mapping[int,¬†List[float]]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a null distribution of proportion of splits on each variable in X</p>
<p>Works by randomly permuting y to remove any true dependence of y on X and calculating feature importance</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>SklearnModel</code></dt>
<dd>Model specification to work with</dd>
<dt><strong><code>X</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Covariate matrix</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Target data</dd>
<dt><strong><code>n_permutations</code></strong> :&ensp;<code>int</code></dt>
<dd>How many permutations to run
The higher the number of permutations, the more accurate the null distribution, but the longer it will take to run</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Mapping[int, List[float]]</code></dt>
<dd>A list of inclusion proportions for each variable in X</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def null_feature_split_proportions_distribution(model: SklearnModel,
                                                X: Union[pd.DataFrame, np.ndarray],
                                                y: np.ndarray,
                                                n_permutations: int=10) -&gt; Mapping[int, List[float]]:
    &#34;&#34;&#34;
    Calculate a null distribution of proportion of splits on each variable in X

    Works by randomly permuting y to remove any true dependence of y on X and calculating feature importance

    Parameters
    ----------
    model: SklearnModel
        Model specification to work with
    X: np.ndarray
        Covariate matrix
    y: np.ndarray
        Target data
    n_permutations: int
        How many permutations to run
        The higher the number of permutations, the more accurate the null distribution, but the longer it will take to run
    Returns
    -------
    Mapping[int, List[float]]
        A list of inclusion proportions for each variable in X
    &#34;&#34;&#34;

    inclusion_dict = {x: [] for x in range(X.shape[1])}

    y_s = [np.random.permutation(y) for _ in range(n_permutations)]
    X_s = [X for _ in y_s]

    fit_models = run_models(model, X_s, y_s)

    for model in fit_models:
        splits_run = feature_split_proportions(model, list(range(X.shape[1])))
        for key, value in splits_run.items():
            inclusion_dict[key].append(value)

    return inclusion_dict</code></pre>
</details>
</dd>
<dt id="imodels.experimental.bartpy.diagnostics.features.partition_into_passed_and_failed_features"><code class="name flex">
<span>def <span class="ident">partition_into_passed_and_failed_features</span></span>(<span>feature_proportions, thresholds)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition_into_passed_and_failed_features(feature_proportions, thresholds):
    kept = kept_features(feature_proportions, thresholds)
    passed_features = {x[0]: x[1] for x in feature_proportions.items() if x[0] in kept}
    failed_features = {x[0]: x[1] for x in feature_proportions.items() if x[0] not in kept}
    return passed_features, failed_features</code></pre>
</details>
</dd>
<dt id="imodels.experimental.bartpy.diagnostics.features.plot_feature_proportions_against_thresholds"><code class="name flex">
<span>def <span class="ident">plot_feature_proportions_against_thresholds</span></span>(<span>feature_proportions, thresholds, ax=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_feature_proportions_against_thresholds(feature_proportions, thresholds, ax=None):
    if ax is None:
        _, ax = plt.subplots(1, 1)
    passed_features, failed_features = partition_into_passed_and_failed_features(feature_proportions, thresholds)

    ax.bar(thresholds.keys(), [x * 100 for x in thresholds.values()], width=0.01, color=&#34;black&#34;, alpha=0.5)
    ax.scatter(passed_features.keys(), [x * 100 for x in passed_features.values()], c=&#34;g&#34;)
    ax.scatter(failed_features.keys(), [x * 100 for x in failed_features.values()], c=&#34;r&#34;)
    ax.set_title(&#34;Feature Importance Compared to Threshold&#34;)
    ax.set_xlabel(&#34;Feature&#34;)
    ax.set_ylabel(&#34;% Splits&#34;)
    return ax</code></pre>
</details>
</dd>
<dt id="imodels.experimental.bartpy.diagnostics.features.plot_feature_split_proportions"><code class="name flex">
<span>def <span class="ident">plot_feature_split_proportions</span></span>(<span>model:¬†<a title="imodels.experimental.bartpy.sklearnmodel.SklearnModel" href="../sklearnmodel.html#imodels.experimental.bartpy.sklearnmodel.SklearnModel">SklearnModel</a>, ax=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_feature_split_proportions(model: SklearnModel, ax=None):
    if ax is None:
        _, ax = plt.subplots(1, 1)
    proportions = feature_split_proportions(model)

    y_pos = np.arange(len(proportions))
    name, count = list(proportions.keys()), list(proportions.values())
    props = pd.DataFrame({&#34;name&#34;: name, &#34;counts&#34;: count}).sort_values(&#34;name&#34;, ascending=True)
    plt.barh(y_pos, props.counts, align=&#39;center&#39;, alpha=0.5)
    plt.yticks(y_pos, props.name)
    plt.xlabel(&#39;Proportion of all splits&#39;)
    plt.ylabel(&#39;Feature&#39;)
    plt.title(&#39;Proportion of Splits Made on Each Variable&#39;)
    return ax</code></pre>
</details>
</dd>
<dt id="imodels.experimental.bartpy.diagnostics.features.plot_null_feature_importance_distributions"><code class="name flex">
<span>def <span class="ident">plot_null_feature_importance_distributions</span></span>(<span>null_distributions:¬†Mapping[int,¬†List[float]], ax=None) ‚Äë>¬†None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_null_feature_importance_distributions(null_distributions: Mapping[int, List[float]], ax=None) -&gt; None:
    if ax is None:
        _, ax = plt.subplots(1, 1)
    df = pd.DataFrame(null_distributions)
    df = pd.DataFrame(df.unstack()).reset_index().drop(&#34;level_1&#34;, axis=1)
    df.columns = [&#34;variable&#34;, &#34;p&#34;]
    sns.boxplot(x=&#34;variable&#34;, y=&#34;p&#34;, data=df, ax=ax)
    ax.set_title(&#34;Null Feature Importance Distribution&#34;)
    return ax</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index üîç</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="imodels.experimental.bartpy.diagnostics" href="index.html">imodels.experimental.bartpy.diagnostics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="imodels.experimental.bartpy.diagnostics.features.feature_split_proportions" href="#imodels.experimental.bartpy.diagnostics.features.feature_split_proportions">feature_split_proportions</a></code></li>
<li><code><a title="imodels.experimental.bartpy.diagnostics.features.global_thresholds" href="#imodels.experimental.bartpy.diagnostics.features.global_thresholds">global_thresholds</a></code></li>
<li><code><a title="imodels.experimental.bartpy.diagnostics.features.is_kept" href="#imodels.experimental.bartpy.diagnostics.features.is_kept">is_kept</a></code></li>
<li><code><a title="imodels.experimental.bartpy.diagnostics.features.kept_features" href="#imodels.experimental.bartpy.diagnostics.features.kept_features">kept_features</a></code></li>
<li><code><a title="imodels.experimental.bartpy.diagnostics.features.local_thresholds" href="#imodels.experimental.bartpy.diagnostics.features.local_thresholds">local_thresholds</a></code></li>
<li><code><a title="imodels.experimental.bartpy.diagnostics.features.null_feature_split_proportions_distribution" href="#imodels.experimental.bartpy.diagnostics.features.null_feature_split_proportions_distribution">null_feature_split_proportions_distribution</a></code></li>
<li><code><a title="imodels.experimental.bartpy.diagnostics.features.partition_into_passed_and_failed_features" href="#imodels.experimental.bartpy.diagnostics.features.partition_into_passed_and_failed_features">partition_into_passed_and_failed_features</a></code></li>
<li><code><a title="imodels.experimental.bartpy.diagnostics.features.plot_feature_proportions_against_thresholds" href="#imodels.experimental.bartpy.diagnostics.features.plot_feature_proportions_against_thresholds">plot_feature_proportions_against_thresholds</a></code></li>
<li><code><a title="imodels.experimental.bartpy.diagnostics.features.plot_feature_split_proportions" href="#imodels.experimental.bartpy.diagnostics.features.plot_feature_split_proportions">plot_feature_split_proportions</a></code></li>
<li><code><a title="imodels.experimental.bartpy.diagnostics.features.plot_null_feature_importance_distributions" href="#imodels.experimental.bartpy.diagnostics.features.plot_null_feature_importance_distributions">plot_null_feature_importance_distributions</a></code></li>
</ul>
</li>
</ul>
<p><img align="center" width=100% src="https://csinva.io/imodels/img/anim.gif"> </img></p>
<!-- add wave animation -->
</nav>
</main>
<footer id="footer">
</footer>
</body>
</html>
<!-- add github corner -->
<a href="https://github.com/csinva/imodels" class="github-corner" aria-label="View source on GitHub"><svg width="120" height="120" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="m128.3,109.0 c113.8,99.7 119.0,89.6 119.0,89.6 c122.0,82.7 120.5,78.6 120.5,78.6 c119.2,72.0 123.4,76.3 123.4,76.3 c127.3,80.9 125.5,87.3 125.5,87.3 c122.9,97.6 130.6,101.9 134.4,103.2" fill="currentcolor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- add wave animation stylesheet -->
<link rel="stylesheet" href="github.css">