<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>imodels.rule_set.rule_fit API documentation</title>
<meta name="description" content="Linear model of tree-based decision rules based on the rulefit algorithm from Friedman and Popescu â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>imodels.rule_set.rule_fit</code></h1>
</header>
<section id="section-intro">
<p>Linear model of tree-based decision rules based on the rulefit algorithm from Friedman and Popescu.</p>
<p>The algorithm can be used for predicting an output vector y given an input matrix X. In the first step a tree ensemble
is generated with gradient boosting. The trees are then used to form rules, where the paths to each node in each tree
form one rule. A rule is a binary decision if an observation is in a given node, which is dependent on the input features
that were used in the splits. The ensemble of rules together with the original input features are then being input in a
L1-regularized linear model, also called Lasso, which estimates the effects of each rule on the output target but at the
same time estimating many of those effects to zero.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Linear model of tree-based decision rules based on the rulefit algorithm from Friedman and Popescu.

The algorithm can be used for predicting an output vector y given an input matrix X. In the first step a tree ensemble
is generated with gradient boosting. The trees are then used to form rules, where the paths to each node in each tree
form one rule. A rule is a binary decision if an observation is in a given node, which is dependent on the input features
that were used in the splits. The ensemble of rules together with the original input features are then being input in a
L1-regularized linear model, also called Lasso, which estimates the effects of each rule on the output target but at the
same time estimating many of those effects to zero.
&#34;&#34;&#34;
import numpy as np
import pandas as pd
from scipy.special import softmax
from sklearn.base import BaseEstimator, ClassifierMixin, RegressorMixin
from sklearn.base import TransformerMixin
from sklearn.utils.multiclass import unique_labels
from sklearn.utils.validation import check_X_y, check_array, check_is_fitted
from typing import List, Tuple

from imodels.rule_set.rule_set import RuleSet
from imodels.util.extract import extract_rulefit
from imodels.util.rule import get_feature_dict, replace_feature_name, Rule
from imodels.util.score import score_linear
from imodels.util.transforms import Winsorizer, FriedScale


class RuleFit(BaseEstimator, TransformerMixin, RuleSet):
    &#34;&#34;&#34;Rulefit class. Rather than using this class directly, should use RuleFitRegressor or RuleFitClassifier


    Parameters
    ----------
    tree_size:      Number of terminal nodes in generated trees. If exp_rand_tree_size=True, 
                    this will be the mean number of terminal nodes.
    sample_fract:   fraction of randomly chosen training observations used to produce each tree. 
                    FP 2004 (Sec. 2)
    max_rules:      total number of terms included in the final model (both linear and rules)
                    approximate total number of candidate rules generated for fitting also is based on this
                    Note that actual number of candidate rules will usually be lower than this due to duplicates.
    memory_par:     scale multiplier (shrinkage factor) applied to each new tree when 
                    sequentially induced. FP 2004 (Sec. 2)
    lin_standardise: If True, the linear terms will be standardised as per Friedman Sec 3.2
                    by multiplying the winsorised variable by 0.4/stdev.
    lin_trim_quantile: If lin_standardise is True, this quantile will be used to trim linear 
                    terms before standardisation.
    exp_rand_tree_size: If True, each boosted tree will have a different maximum number of 
                    terminal nodes based on an exponential distribution about tree_size. 
                    (Friedman Sec 3.3)
    include_linear: Include linear terms as opposed to only rules
    random_state:   Integer to initialise random objects and provide repeatability.
    tree_generator: Optional: this object will be used as provided to generate the rules. 
                    This will override almost all the other properties above. 
                    Must be GradientBoostingRegressor or GradientBoostingClassifier, optional (default=None)

    Attributes
    ----------
    rule_ensemble: RuleEnsemble
        The rule ensemble

    feature_names: list of strings, optional (default=None)
        The names of the features (columns)

    &#34;&#34;&#34;

    def __init__(self,
                 n_estimators=100,
                 tree_size=4,
                 sample_fract=&#39;default&#39;,
                 max_rules=30,
                 memory_par=0.01,
                 tree_generator=None,
                 lin_trim_quantile=0.025,
                 lin_standardise=True,
                 exp_rand_tree_size=True,
                 include_linear=True,
                 alpha=None,
                 random_state=None):
        self.n_estimators = n_estimators
        self.tree_size = tree_size
        self.sample_fract = sample_fract
        self.max_rules = max_rules
        self.memory_par = memory_par
        self.tree_generator = tree_generator
        self.lin_trim_quantile = lin_trim_quantile
        self.lin_standardise = lin_standardise
        self.exp_rand_tree_size = exp_rand_tree_size
        self.include_linear = include_linear
        self.alpha = alpha
        self.random_state = random_state

        self.winsorizer = Winsorizer(trim_quantile=self.lin_trim_quantile)
        self.friedscale = FriedScale(self.winsorizer)
        self.stddev = None
        self.mean = None

        self._init_prediction_task()  # decides between regressor and classifier

    def _init_prediction_task(self):
        &#34;&#34;&#34;
        RuleFitRegressor and RuleFitClassifier override this method
        to alter the prediction task. When using this class directly,
        it is equivalent to RuleFitRegressor
        &#34;&#34;&#34;
        self.prediction_task = &#39;regression&#39;

    def fit(self, X, y=None, feature_names=None):
        &#34;&#34;&#34;Fit and estimate linear combination of rule ensemble

        &#34;&#34;&#34;
        X, y = check_X_y(X, y)
        if self.prediction_task == &#39;classification&#39;:
            self.classes_ = unique_labels(y)
        self.n_features_in_ = X.shape[1]

        self.n_features_ = X.shape[1]
        self.feature_dict_ = get_feature_dict(X.shape[1], feature_names)
        self.feature_placeholders = np.array(list(self.feature_dict_.keys()))
        self.feature_names = np.array(list(self.feature_dict_.values()))

        extracted_rules = self._extract_rules(X, y)
        self.rules_without_feature_names_, self.coef, self.intercept = self._score_rules(X, y, extracted_rules)
        self.rules_ = [
            replace_feature_name(rule, self.feature_dict_) for rule in self.rules_without_feature_names_
        ]
        self.complexity_ = self._get_complexity()

        return self

    def predict_continuous_output(self, X):
        &#34;&#34;&#34;Predict outcome of linear model for X
        &#34;&#34;&#34;
        if type(X) == pd.DataFrame:
            X = X.values.astype(np.float32)

        y_pred = np.zeros(X.shape[0])
        y_pred += self.eval_weighted_rule_sum(X)

        if self.include_linear:
            if self.lin_standardise:
                X = self.friedscale.scale(X)
            y_pred += X @ self.coef[:X.shape[1]]
        return y_pred + self.intercept

    def predict(self, X):
        &#39;&#39;&#39;Predict. For regression returns continuous output.
        For classification, returns discrete output.
        &#39;&#39;&#39;
        check_is_fitted(self)
        X = check_array(X)
        if self.prediction_task == &#39;regression&#39;:
            return self.predict_continuous_output(X)
        else:
            return np.argmax(self.predict_proba(X), axis=1)

    def predict_proba(self, X):
        check_is_fitted(self)
        X = check_array(X)
        continuous_output = self.predict_continuous_output(X)
        logits = np.vstack((1 - continuous_output, continuous_output)).transpose()
        return softmax(logits, axis=1)

    def transform(self, X=None, rules=None):
        &#34;&#34;&#34;Transform dataset.

        Parameters
        ----------
        X : array-like matrix, shape=(n_samples, n_features)
            Input data to be transformed. Use ``dtype=np.float32`` for maximum
            efficiency.

        Returns
        -------
        X_transformed: matrix, shape=(n_samples, n_out)
            Transformed data set
        &#34;&#34;&#34;
        df = pd.DataFrame(X, columns=self.feature_placeholders)
        X_transformed = np.zeros((X.shape[0], len(rules)))
        for i, r in enumerate(rules):
            features_r_uses = [term.split(&#39; &#39;)[0] for term in r.split(&#39; and &#39;)] 
            X_transformed[df[features_r_uses].query(r).index.values, i] = 1
        return X_transformed

    def get_rules(self, exclude_zero_coef=False, subregion=None):
        &#34;&#34;&#34;Return the estimated rules

        Parameters
        ----------
        exclude_zero_coef: If True (default), returns only the rules with an estimated
                           coefficient not equalt to  zero.

        subregion: If None (default) returns global importances (FP 2004 eq. 28/29), else returns importance over 
                           subregion of inputs (FP 2004 eq. 30/31/32).

        Returns
        -------
        rules: pandas.DataFrame with the rules. Column &#39;rule&#39; describes the rule, &#39;coef&#39; holds
               the coefficients and &#39;support&#39; the support of the rule in the training
               data set (X)
        &#34;&#34;&#34;
        n_features = len(self.coef) - len(self.rules_)
        rule_ensemble = list(self.rules_without_feature_names_)
        output_rules = []
        ## Add coefficients for linear effects
        for i in range(0, n_features):
            if self.lin_standardise:
                coef = self.coef[i] * self.friedscale.scale_multipliers[i]
            else:
                coef = self.coef[i]
            if subregion is None:
                importance = abs(coef) * self.stddev[i]
            else:
                subregion = np.array(subregion)
                importance = sum(abs(coef) * abs([x[i] for x in self.winsorizer.trim(subregion)] - self.mean[i])) / len(
                    subregion)
            output_rules += [(self.feature_names[i], &#39;linear&#39;, coef, 1, importance)]

        ## Add rules
        for i in range(0, len(self.rules_)):
            rule = rule_ensemble[i]
            coef = self.coef[i + n_features]

            if subregion is None:
                importance = abs(coef) * (rule.support * (1 - rule.support)) ** (1 / 2)
            else:
                rkx = self.transform(subregion, [rule])[:, -1]
                importance = sum(abs(coef) * abs(rkx - rule.support)) / len(subregion)

            output_rules += [(self.rules_[i].rule, &#39;rule&#39;, coef, rule.support, importance)]
        rules = pd.DataFrame(output_rules, columns=[&#34;rule&#34;, &#34;type&#34;, &#34;coef&#34;, &#34;support&#34;, &#34;importance&#34;])
        if exclude_zero_coef:
            rules = rules.ix[rules.coef != 0]
        return rules

    def visualize(self):
        rules = self.get_rules()
        rules = rules[rules.coef != 0].sort_values(&#34;support&#34;, ascending=False)
        pd.set_option(&#39;display.max_colwidth&#39;, -1)
        return rules[[&#39;rule&#39;, &#39;coef&#39;]].round(3)

    def _extract_rules(self, X, y) -&gt; List[Rule]:
        return extract_rulefit(X, y,
                               feature_names=self.feature_placeholders,
                               n_estimators=self.n_estimators,
                               tree_size=self.tree_size,
                               memory_par=self.memory_par,
                               tree_generator=self.tree_generator,
                               exp_rand_tree_size=self.exp_rand_tree_size,
                               random_state=self.random_state)

    def _score_rules(self, X, y, rules) -&gt; Tuple[List[Rule], List[float], float]:
        X_concat = np.zeros([X.shape[0], 0])

        # standardise linear variables if requested (for regression model only)
        if self.include_linear:

            # standard deviation and mean of winsorized features
            self.winsorizer.train(X)
            winsorized_X = self.winsorizer.trim(X)
            self.stddev = np.std(winsorized_X, axis=0)
            self.mean = np.mean(winsorized_X, axis=0)

            if self.lin_standardise:
                self.friedscale.train(X)
                X_regn = self.friedscale.scale(X)
            else:
                X_regn = X.copy()
            X_concat = np.concatenate((X_concat, X_regn), axis=1)

        X_rules = self.transform(X, rules)
        if X_rules.shape[0] &gt; 0:
            X_concat = np.concatenate((X_concat, X_rules), axis=1)
        
        # no rules fit and self.include_linear == False
        if X_concat.shape[1] == 0:
            return [], [], 0

        return score_linear(X_concat, y, rules,
                            prediction_task=self.prediction_task,
                            max_rules=self.max_rules,
                            alpha=self.alpha,
                            random_state=self.random_state)


class RuleFitRegressor(RuleFit, RegressorMixin):
    def _init_prediction_task(self):
        self.prediction_task = &#39;regression&#39;


class RuleFitClassifier(RuleFit, ClassifierMixin):
    def _init_prediction_task(self):
        self.prediction_task = &#39;classification&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="imodels.rule_set.rule_fit.RuleFit"><code class="flex name class">
<span>class <span class="ident">RuleFit</span></span>
<span>(</span><span>n_estimators=100, tree_size=4, sample_fract='default', max_rules=30, memory_par=0.01, tree_generator=None, lin_trim_quantile=0.025, lin_standardise=True, exp_rand_tree_size=True, include_linear=True, alpha=None, random_state=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Rulefit class. Rather than using this class directly, should use RuleFitRegressor or RuleFitClassifier</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tree_size</code></strong> :&ensp;
<code>Number</code> of <code>terminal</code> <code>nodes</code> <code>in</code> <code>generated</code> <code>trees.</code> <code>If</code> <code>exp_rand_tree_size</code>=<code>True</code>,</dt>
<dd>this will be the mean number of terminal nodes.</dd>
<dt><strong><code>sample_fract</code></strong> :&ensp;
<code>fraction</code> of <code>randomly</code> <code>chosen</code> <code>training</code> <code>observations</code> <code>used</code> <code>to</code> <code>produce</code> <code>each</code> <code>tree.</code></dt>
<dd>FP 2004 (Sec. 2)</dd>
<dt><strong><code>max_rules</code></strong> :&ensp;
<code>total</code> <code>number</code> of <code>terms</code> <code>included</code> <code>in</code> <code>the</code> <code>final</code> <code>model</code> (<code>both</code> <code>linear</code> <code>and</code> <code>rules</code>)</dt>
<dd>approximate total number of candidate rules generated for fitting also is based on this
Note that actual number of candidate rules will usually be lower than this due to duplicates.</dd>
<dt><strong><code>memory_par</code></strong> :&ensp;
<code>scale</code> <code>multiplier</code> (<code>shrinkage</code> <code>factor</code>) <code>applied</code> <code>to</code> <code>each</code> <code>new</code> <code>tree</code> <code>when</code></dt>
<dd>sequentially induced. FP 2004 (Sec. 2)</dd>
<dt><strong><code>lin_standardise</code></strong> :&ensp;<code>If</code> <code>True</code>, <code>the</code> <code>linear</code> <code>terms</code> <code>will</code> <code>be</code> <code>standardised</code> <code>as</code> <code>per</code> <code>Friedman</code> <code>Sec</code> <code>3.2</code></dt>
<dd>by multiplying the winsorised variable by 0.4/stdev.</dd>
<dt><strong><code>lin_trim_quantile</code></strong> :&ensp;<code>If</code> <code>lin_standardise</code> <code>is</code> <code>True</code>, <code>this</code> <code>quantile</code> <code>will</code> <code>be</code> <code>used</code> <code>to</code> <code>trim</code> <code>linear</code></dt>
<dd>terms before standardisation.</dd>
<dt><strong><code>exp_rand_tree_size</code></strong> :&ensp;<code>If</code> <code>True</code>, <code>each</code> <code>boosted</code> <code>tree</code> <code>will</code> <code>have</code> <code>a</code> <code>different</code> <code>maximum</code> <code>number</code> of</dt>
<dd>terminal nodes based on an exponential distribution about tree_size.
(Friedman Sec 3.3)</dd>
<dt><strong><code>include_linear</code></strong> :&ensp;<code>Include</code> <code>linear</code> <code>terms</code> <code>as</code> <code>opposed</code> <code>to</code> <code>only</code> <code>rules</code></dt>
<dd>&nbsp;</dd>
<dt>random_state:
Integer to initialise random objects and provide repeatability.</dt>
<dt><strong><code>tree_generator</code></strong> :&ensp;<code>Optional</code>: <code>this</code> <code>object</code> <code>will</code> <code>be</code> <code>used</code> <code>as</code> <code>provided</code> <code>to</code> <code>generate</code> <code>the</code> <code>rules.</code></dt>
<dd>This will override almost all the other properties above.
Must be GradientBoostingRegressor or GradientBoostingClassifier, optional (default=None)</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>rule_ensemble</code></strong> :&ensp;<code>RuleEnsemble</code></dt>
<dd>The rule ensemble</dd>
<dt><strong><code>feature_names</code></strong> :&ensp;<code>list</code> of <code>strings</code>, optional (default=<code>None</code>)</dt>
<dd>The names of the features (columns)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RuleFit(BaseEstimator, TransformerMixin, RuleSet):
    &#34;&#34;&#34;Rulefit class. Rather than using this class directly, should use RuleFitRegressor or RuleFitClassifier


    Parameters
    ----------
    tree_size:      Number of terminal nodes in generated trees. If exp_rand_tree_size=True, 
                    this will be the mean number of terminal nodes.
    sample_fract:   fraction of randomly chosen training observations used to produce each tree. 
                    FP 2004 (Sec. 2)
    max_rules:      total number of terms included in the final model (both linear and rules)
                    approximate total number of candidate rules generated for fitting also is based on this
                    Note that actual number of candidate rules will usually be lower than this due to duplicates.
    memory_par:     scale multiplier (shrinkage factor) applied to each new tree when 
                    sequentially induced. FP 2004 (Sec. 2)
    lin_standardise: If True, the linear terms will be standardised as per Friedman Sec 3.2
                    by multiplying the winsorised variable by 0.4/stdev.
    lin_trim_quantile: If lin_standardise is True, this quantile will be used to trim linear 
                    terms before standardisation.
    exp_rand_tree_size: If True, each boosted tree will have a different maximum number of 
                    terminal nodes based on an exponential distribution about tree_size. 
                    (Friedman Sec 3.3)
    include_linear: Include linear terms as opposed to only rules
    random_state:   Integer to initialise random objects and provide repeatability.
    tree_generator: Optional: this object will be used as provided to generate the rules. 
                    This will override almost all the other properties above. 
                    Must be GradientBoostingRegressor or GradientBoostingClassifier, optional (default=None)

    Attributes
    ----------
    rule_ensemble: RuleEnsemble
        The rule ensemble

    feature_names: list of strings, optional (default=None)
        The names of the features (columns)

    &#34;&#34;&#34;

    def __init__(self,
                 n_estimators=100,
                 tree_size=4,
                 sample_fract=&#39;default&#39;,
                 max_rules=30,
                 memory_par=0.01,
                 tree_generator=None,
                 lin_trim_quantile=0.025,
                 lin_standardise=True,
                 exp_rand_tree_size=True,
                 include_linear=True,
                 alpha=None,
                 random_state=None):
        self.n_estimators = n_estimators
        self.tree_size = tree_size
        self.sample_fract = sample_fract
        self.max_rules = max_rules
        self.memory_par = memory_par
        self.tree_generator = tree_generator
        self.lin_trim_quantile = lin_trim_quantile
        self.lin_standardise = lin_standardise
        self.exp_rand_tree_size = exp_rand_tree_size
        self.include_linear = include_linear
        self.alpha = alpha
        self.random_state = random_state

        self.winsorizer = Winsorizer(trim_quantile=self.lin_trim_quantile)
        self.friedscale = FriedScale(self.winsorizer)
        self.stddev = None
        self.mean = None

        self._init_prediction_task()  # decides between regressor and classifier

    def _init_prediction_task(self):
        &#34;&#34;&#34;
        RuleFitRegressor and RuleFitClassifier override this method
        to alter the prediction task. When using this class directly,
        it is equivalent to RuleFitRegressor
        &#34;&#34;&#34;
        self.prediction_task = &#39;regression&#39;

    def fit(self, X, y=None, feature_names=None):
        &#34;&#34;&#34;Fit and estimate linear combination of rule ensemble

        &#34;&#34;&#34;
        X, y = check_X_y(X, y)
        if self.prediction_task == &#39;classification&#39;:
            self.classes_ = unique_labels(y)
        self.n_features_in_ = X.shape[1]

        self.n_features_ = X.shape[1]
        self.feature_dict_ = get_feature_dict(X.shape[1], feature_names)
        self.feature_placeholders = np.array(list(self.feature_dict_.keys()))
        self.feature_names = np.array(list(self.feature_dict_.values()))

        extracted_rules = self._extract_rules(X, y)
        self.rules_without_feature_names_, self.coef, self.intercept = self._score_rules(X, y, extracted_rules)
        self.rules_ = [
            replace_feature_name(rule, self.feature_dict_) for rule in self.rules_without_feature_names_
        ]
        self.complexity_ = self._get_complexity()

        return self

    def predict_continuous_output(self, X):
        &#34;&#34;&#34;Predict outcome of linear model for X
        &#34;&#34;&#34;
        if type(X) == pd.DataFrame:
            X = X.values.astype(np.float32)

        y_pred = np.zeros(X.shape[0])
        y_pred += self.eval_weighted_rule_sum(X)

        if self.include_linear:
            if self.lin_standardise:
                X = self.friedscale.scale(X)
            y_pred += X @ self.coef[:X.shape[1]]
        return y_pred + self.intercept

    def predict(self, X):
        &#39;&#39;&#39;Predict. For regression returns continuous output.
        For classification, returns discrete output.
        &#39;&#39;&#39;
        check_is_fitted(self)
        X = check_array(X)
        if self.prediction_task == &#39;regression&#39;:
            return self.predict_continuous_output(X)
        else:
            return np.argmax(self.predict_proba(X), axis=1)

    def predict_proba(self, X):
        check_is_fitted(self)
        X = check_array(X)
        continuous_output = self.predict_continuous_output(X)
        logits = np.vstack((1 - continuous_output, continuous_output)).transpose()
        return softmax(logits, axis=1)

    def transform(self, X=None, rules=None):
        &#34;&#34;&#34;Transform dataset.

        Parameters
        ----------
        X : array-like matrix, shape=(n_samples, n_features)
            Input data to be transformed. Use ``dtype=np.float32`` for maximum
            efficiency.

        Returns
        -------
        X_transformed: matrix, shape=(n_samples, n_out)
            Transformed data set
        &#34;&#34;&#34;
        df = pd.DataFrame(X, columns=self.feature_placeholders)
        X_transformed = np.zeros((X.shape[0], len(rules)))
        for i, r in enumerate(rules):
            features_r_uses = [term.split(&#39; &#39;)[0] for term in r.split(&#39; and &#39;)] 
            X_transformed[df[features_r_uses].query(r).index.values, i] = 1
        return X_transformed

    def get_rules(self, exclude_zero_coef=False, subregion=None):
        &#34;&#34;&#34;Return the estimated rules

        Parameters
        ----------
        exclude_zero_coef: If True (default), returns only the rules with an estimated
                           coefficient not equalt to  zero.

        subregion: If None (default) returns global importances (FP 2004 eq. 28/29), else returns importance over 
                           subregion of inputs (FP 2004 eq. 30/31/32).

        Returns
        -------
        rules: pandas.DataFrame with the rules. Column &#39;rule&#39; describes the rule, &#39;coef&#39; holds
               the coefficients and &#39;support&#39; the support of the rule in the training
               data set (X)
        &#34;&#34;&#34;
        n_features = len(self.coef) - len(self.rules_)
        rule_ensemble = list(self.rules_without_feature_names_)
        output_rules = []
        ## Add coefficients for linear effects
        for i in range(0, n_features):
            if self.lin_standardise:
                coef = self.coef[i] * self.friedscale.scale_multipliers[i]
            else:
                coef = self.coef[i]
            if subregion is None:
                importance = abs(coef) * self.stddev[i]
            else:
                subregion = np.array(subregion)
                importance = sum(abs(coef) * abs([x[i] for x in self.winsorizer.trim(subregion)] - self.mean[i])) / len(
                    subregion)
            output_rules += [(self.feature_names[i], &#39;linear&#39;, coef, 1, importance)]

        ## Add rules
        for i in range(0, len(self.rules_)):
            rule = rule_ensemble[i]
            coef = self.coef[i + n_features]

            if subregion is None:
                importance = abs(coef) * (rule.support * (1 - rule.support)) ** (1 / 2)
            else:
                rkx = self.transform(subregion, [rule])[:, -1]
                importance = sum(abs(coef) * abs(rkx - rule.support)) / len(subregion)

            output_rules += [(self.rules_[i].rule, &#39;rule&#39;, coef, rule.support, importance)]
        rules = pd.DataFrame(output_rules, columns=[&#34;rule&#34;, &#34;type&#34;, &#34;coef&#34;, &#34;support&#34;, &#34;importance&#34;])
        if exclude_zero_coef:
            rules = rules.ix[rules.coef != 0]
        return rules

    def visualize(self):
        rules = self.get_rules()
        rules = rules[rules.coef != 0].sort_values(&#34;support&#34;, ascending=False)
        pd.set_option(&#39;display.max_colwidth&#39;, -1)
        return rules[[&#39;rule&#39;, &#39;coef&#39;]].round(3)

    def _extract_rules(self, X, y) -&gt; List[Rule]:
        return extract_rulefit(X, y,
                               feature_names=self.feature_placeholders,
                               n_estimators=self.n_estimators,
                               tree_size=self.tree_size,
                               memory_par=self.memory_par,
                               tree_generator=self.tree_generator,
                               exp_rand_tree_size=self.exp_rand_tree_size,
                               random_state=self.random_state)

    def _score_rules(self, X, y, rules) -&gt; Tuple[List[Rule], List[float], float]:
        X_concat = np.zeros([X.shape[0], 0])

        # standardise linear variables if requested (for regression model only)
        if self.include_linear:

            # standard deviation and mean of winsorized features
            self.winsorizer.train(X)
            winsorized_X = self.winsorizer.trim(X)
            self.stddev = np.std(winsorized_X, axis=0)
            self.mean = np.mean(winsorized_X, axis=0)

            if self.lin_standardise:
                self.friedscale.train(X)
                X_regn = self.friedscale.scale(X)
            else:
                X_regn = X.copy()
            X_concat = np.concatenate((X_concat, X_regn), axis=1)

        X_rules = self.transform(X, rules)
        if X_rules.shape[0] &gt; 0:
            X_concat = np.concatenate((X_concat, X_rules), axis=1)
        
        # no rules fit and self.include_linear == False
        if X_concat.shape[1] == 0:
            return [], [], 0

        return score_linear(X_concat, y, rules,
                            prediction_task=self.prediction_task,
                            max_rules=self.max_rules,
                            alpha=self.alpha,
                            random_state=self.random_state)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sklearn.base.BaseEstimator</li>
<li>sklearn.base.TransformerMixin</li>
<li><a title="imodels.rule_set.rule_set.RuleSet" href="rule_set.html#imodels.rule_set.rule_set.RuleSet">RuleSet</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="imodels.rule_set.rule_fit.RuleFitRegressor" href="#imodels.rule_set.rule_fit.RuleFitRegressor">RuleFitRegressor</a></li>
<li><a title="imodels.rule_set.rule_fit.RuleFitClassifier" href="#imodels.rule_set.rule_fit.RuleFitClassifier">RuleFitClassifier</a></li>
<li><a title="imodels.rule_set.fplasso.FPLasso" href="fplasso.html#imodels.rule_set.fplasso.FPLasso">FPLasso</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="imodels.rule_set.rule_fit.RuleFit.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, X, y=None, feature_names=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Fit and estimate linear combination of rule ensemble</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, X, y=None, feature_names=None):
    &#34;&#34;&#34;Fit and estimate linear combination of rule ensemble

    &#34;&#34;&#34;
    X, y = check_X_y(X, y)
    if self.prediction_task == &#39;classification&#39;:
        self.classes_ = unique_labels(y)
    self.n_features_in_ = X.shape[1]

    self.n_features_ = X.shape[1]
    self.feature_dict_ = get_feature_dict(X.shape[1], feature_names)
    self.feature_placeholders = np.array(list(self.feature_dict_.keys()))
    self.feature_names = np.array(list(self.feature_dict_.values()))

    extracted_rules = self._extract_rules(X, y)
    self.rules_without_feature_names_, self.coef, self.intercept = self._score_rules(X, y, extracted_rules)
    self.rules_ = [
        replace_feature_name(rule, self.feature_dict_) for rule in self.rules_without_feature_names_
    ]
    self.complexity_ = self._get_complexity()

    return self</code></pre>
</details>
</dd>
<dt id="imodels.rule_set.rule_fit.RuleFit.get_rules"><code class="name flex">
<span>def <span class="ident">get_rules</span></span>(<span>self, exclude_zero_coef=False, subregion=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the estimated rules</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>exclude_zero_coef</code></strong> :&ensp;<code>If</code> <code>True</code> (default), <code>returns</code> <code>only</code> <code>the</code> <code>rules</code> <code>with</code> <code>an</code> <code>estimated</code></dt>
<dd>coefficient not equalt to
zero.</dd>
<dt><strong><code>subregion</code></strong> :&ensp;<code>If</code> <code>None</code> (default) <code>returns</code> <code>global</code> <code>importances</code> (<code>FP</code> <code>2004</code> <code>eq.</code> <code>28</code>/<code>29</code>), <code>else</code> <code>returns</code> <code>importance</code> <code>over</code></dt>
<dd>subregion of inputs (FP 2004 eq. 30/31/32).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rules</code></strong> :&ensp;<code>pandas.DataFrame</code> <code>with</code> <code>the</code> <code>rules.</code> <code>Column</code> <code>'rule'</code> <code>describes</code> <code>the</code> <code>rule</code>, <code>'coef'</code> <code>holds</code></dt>
<dd>the coefficients and 'support' the support of the rule in the training
data set (X)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rules(self, exclude_zero_coef=False, subregion=None):
    &#34;&#34;&#34;Return the estimated rules

    Parameters
    ----------
    exclude_zero_coef: If True (default), returns only the rules with an estimated
                       coefficient not equalt to  zero.

    subregion: If None (default) returns global importances (FP 2004 eq. 28/29), else returns importance over 
                       subregion of inputs (FP 2004 eq. 30/31/32).

    Returns
    -------
    rules: pandas.DataFrame with the rules. Column &#39;rule&#39; describes the rule, &#39;coef&#39; holds
           the coefficients and &#39;support&#39; the support of the rule in the training
           data set (X)
    &#34;&#34;&#34;
    n_features = len(self.coef) - len(self.rules_)
    rule_ensemble = list(self.rules_without_feature_names_)
    output_rules = []
    ## Add coefficients for linear effects
    for i in range(0, n_features):
        if self.lin_standardise:
            coef = self.coef[i] * self.friedscale.scale_multipliers[i]
        else:
            coef = self.coef[i]
        if subregion is None:
            importance = abs(coef) * self.stddev[i]
        else:
            subregion = np.array(subregion)
            importance = sum(abs(coef) * abs([x[i] for x in self.winsorizer.trim(subregion)] - self.mean[i])) / len(
                subregion)
        output_rules += [(self.feature_names[i], &#39;linear&#39;, coef, 1, importance)]

    ## Add rules
    for i in range(0, len(self.rules_)):
        rule = rule_ensemble[i]
        coef = self.coef[i + n_features]

        if subregion is None:
            importance = abs(coef) * (rule.support * (1 - rule.support)) ** (1 / 2)
        else:
            rkx = self.transform(subregion, [rule])[:, -1]
            importance = sum(abs(coef) * abs(rkx - rule.support)) / len(subregion)

        output_rules += [(self.rules_[i].rule, &#39;rule&#39;, coef, rule.support, importance)]
    rules = pd.DataFrame(output_rules, columns=[&#34;rule&#34;, &#34;type&#34;, &#34;coef&#34;, &#34;support&#34;, &#34;importance&#34;])
    if exclude_zero_coef:
        rules = rules.ix[rules.coef != 0]
    return rules</code></pre>
</details>
</dd>
<dt id="imodels.rule_set.rule_fit.RuleFit.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, X)</span>
</code></dt>
<dd>
<section class="desc"><p>Predict. For regression returns continuous output.
For classification, returns discrete output.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, X):
    &#39;&#39;&#39;Predict. For regression returns continuous output.
    For classification, returns discrete output.
    &#39;&#39;&#39;
    check_is_fitted(self)
    X = check_array(X)
    if self.prediction_task == &#39;regression&#39;:
        return self.predict_continuous_output(X)
    else:
        return np.argmax(self.predict_proba(X), axis=1)</code></pre>
</details>
</dd>
<dt id="imodels.rule_set.rule_fit.RuleFit.predict_continuous_output"><code class="name flex">
<span>def <span class="ident">predict_continuous_output</span></span>(<span>self, X)</span>
</code></dt>
<dd>
<section class="desc"><p>Predict outcome of linear model for X</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_continuous_output(self, X):
    &#34;&#34;&#34;Predict outcome of linear model for X
    &#34;&#34;&#34;
    if type(X) == pd.DataFrame:
        X = X.values.astype(np.float32)

    y_pred = np.zeros(X.shape[0])
    y_pred += self.eval_weighted_rule_sum(X)

    if self.include_linear:
        if self.lin_standardise:
            X = self.friedscale.scale(X)
        y_pred += X @ self.coef[:X.shape[1]]
    return y_pred + self.intercept</code></pre>
</details>
</dd>
<dt id="imodels.rule_set.rule_fit.RuleFit.predict_proba"><code class="name flex">
<span>def <span class="ident">predict_proba</span></span>(<span>self, X)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_proba(self, X):
    check_is_fitted(self)
    X = check_array(X)
    continuous_output = self.predict_continuous_output(X)
    logits = np.vstack((1 - continuous_output, continuous_output)).transpose()
    return softmax(logits, axis=1)</code></pre>
</details>
</dd>
<dt id="imodels.rule_set.rule_fit.RuleFit.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, X=None, rules=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Transform dataset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>array</code>-<code>like</code> <code>matrix</code>, <code>shape</code>=(<code>n_samples</code>, <code>n_features</code>)</dt>
<dd>Input data to be transformed. Use <code>dtype=np.float32</code> for maximum
efficiency.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>X_transformed</code></strong> :&ensp;<code>matrix</code>, <code>shape</code>=(<code>n_samples</code>, <code>n_out</code>)</dt>
<dd>Transformed data set</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self, X=None, rules=None):
    &#34;&#34;&#34;Transform dataset.

    Parameters
    ----------
    X : array-like matrix, shape=(n_samples, n_features)
        Input data to be transformed. Use ``dtype=np.float32`` for maximum
        efficiency.

    Returns
    -------
    X_transformed: matrix, shape=(n_samples, n_out)
        Transformed data set
    &#34;&#34;&#34;
    df = pd.DataFrame(X, columns=self.feature_placeholders)
    X_transformed = np.zeros((X.shape[0], len(rules)))
    for i, r in enumerate(rules):
        features_r_uses = [term.split(&#39; &#39;)[0] for term in r.split(&#39; and &#39;)] 
        X_transformed[df[features_r_uses].query(r).index.values, i] = 1
    return X_transformed</code></pre>
</details>
</dd>
<dt id="imodels.rule_set.rule_fit.RuleFit.visualize"><code class="name flex">
<span>def <span class="ident">visualize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualize(self):
    rules = self.get_rules()
    rules = rules[rules.coef != 0].sort_values(&#34;support&#34;, ascending=False)
    pd.set_option(&#39;display.max_colwidth&#39;, -1)
    return rules[[&#39;rule&#39;, &#39;coef&#39;]].round(3)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="imodels.rule_set.rule_fit.RuleFitClassifier"><code class="flex name class">
<span>class <span class="ident">RuleFitClassifier</span></span>
<span>(</span><span>n_estimators=100, tree_size=4, sample_fract='default', max_rules=30, memory_par=0.01, tree_generator=None, lin_trim_quantile=0.025, lin_standardise=True, exp_rand_tree_size=True, include_linear=True, alpha=None, random_state=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Rulefit class. Rather than using this class directly, should use RuleFitRegressor or RuleFitClassifier</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tree_size</code></strong> :&ensp;
<code>Number</code> of <code>terminal</code> <code>nodes</code> <code>in</code> <code>generated</code> <code>trees.</code> <code>If</code> <code>exp_rand_tree_size</code>=<code>True</code>,</dt>
<dd>this will be the mean number of terminal nodes.</dd>
<dt><strong><code>sample_fract</code></strong> :&ensp;
<code>fraction</code> of <code>randomly</code> <code>chosen</code> <code>training</code> <code>observations</code> <code>used</code> <code>to</code> <code>produce</code> <code>each</code> <code>tree.</code></dt>
<dd>FP 2004 (Sec. 2)</dd>
<dt><strong><code>max_rules</code></strong> :&ensp;
<code>total</code> <code>number</code> of <code>terms</code> <code>included</code> <code>in</code> <code>the</code> <code>final</code> <code>model</code> (<code>both</code> <code>linear</code> <code>and</code> <code>rules</code>)</dt>
<dd>approximate total number of candidate rules generated for fitting also is based on this
Note that actual number of candidate rules will usually be lower than this due to duplicates.</dd>
<dt><strong><code>memory_par</code></strong> :&ensp;
<code>scale</code> <code>multiplier</code> (<code>shrinkage</code> <code>factor</code>) <code>applied</code> <code>to</code> <code>each</code> <code>new</code> <code>tree</code> <code>when</code></dt>
<dd>sequentially induced. FP 2004 (Sec. 2)</dd>
<dt><strong><code>lin_standardise</code></strong> :&ensp;<code>If</code> <code>True</code>, <code>the</code> <code>linear</code> <code>terms</code> <code>will</code> <code>be</code> <code>standardised</code> <code>as</code> <code>per</code> <code>Friedman</code> <code>Sec</code> <code>3.2</code></dt>
<dd>by multiplying the winsorised variable by 0.4/stdev.</dd>
<dt><strong><code>lin_trim_quantile</code></strong> :&ensp;<code>If</code> <code>lin_standardise</code> <code>is</code> <code>True</code>, <code>this</code> <code>quantile</code> <code>will</code> <code>be</code> <code>used</code> <code>to</code> <code>trim</code> <code>linear</code></dt>
<dd>terms before standardisation.</dd>
<dt><strong><code>exp_rand_tree_size</code></strong> :&ensp;<code>If</code> <code>True</code>, <code>each</code> <code>boosted</code> <code>tree</code> <code>will</code> <code>have</code> <code>a</code> <code>different</code> <code>maximum</code> <code>number</code> of</dt>
<dd>terminal nodes based on an exponential distribution about tree_size.
(Friedman Sec 3.3)</dd>
<dt><strong><code>include_linear</code></strong> :&ensp;<code>Include</code> <code>linear</code> <code>terms</code> <code>as</code> <code>opposed</code> <code>to</code> <code>only</code> <code>rules</code></dt>
<dd>&nbsp;</dd>
<dt>random_state:
Integer to initialise random objects and provide repeatability.</dt>
<dt><strong><code>tree_generator</code></strong> :&ensp;<code>Optional</code>: <code>this</code> <code>object</code> <code>will</code> <code>be</code> <code>used</code> <code>as</code> <code>provided</code> <code>to</code> <code>generate</code> <code>the</code> <code>rules.</code></dt>
<dd>This will override almost all the other properties above.
Must be GradientBoostingRegressor or GradientBoostingClassifier, optional (default=None)</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>rule_ensemble</code></strong> :&ensp;<code>RuleEnsemble</code></dt>
<dd>The rule ensemble</dd>
<dt><strong><code>feature_names</code></strong> :&ensp;<code>list</code> of <code>strings</code>, optional (default=<code>None</code>)</dt>
<dd>The names of the features (columns)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RuleFitClassifier(RuleFit, ClassifierMixin):
    def _init_prediction_task(self):
        self.prediction_task = &#39;classification&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="imodels.rule_set.rule_fit.RuleFit" href="#imodels.rule_set.rule_fit.RuleFit">RuleFit</a></li>
<li>sklearn.base.BaseEstimator</li>
<li>sklearn.base.TransformerMixin</li>
<li><a title="imodels.rule_set.rule_set.RuleSet" href="rule_set.html#imodels.rule_set.rule_set.RuleSet">RuleSet</a></li>
<li>sklearn.base.ClassifierMixin</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="imodels.rule_set.rule_fit.RuleFit" href="#imodels.rule_set.rule_fit.RuleFit">RuleFit</a></b></code>:
<ul class="hlist">
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.fit" href="#imodels.rule_set.rule_fit.RuleFit.fit">fit</a></code></li>
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.get_rules" href="#imodels.rule_set.rule_fit.RuleFit.get_rules">get_rules</a></code></li>
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.predict" href="#imodels.rule_set.rule_fit.RuleFit.predict">predict</a></code></li>
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.predict_continuous_output" href="#imodels.rule_set.rule_fit.RuleFit.predict_continuous_output">predict_continuous_output</a></code></li>
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.transform" href="#imodels.rule_set.rule_fit.RuleFit.transform">transform</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="imodels.rule_set.rule_fit.RuleFitRegressor"><code class="flex name class">
<span>class <span class="ident">RuleFitRegressor</span></span>
<span>(</span><span>n_estimators=100, tree_size=4, sample_fract='default', max_rules=30, memory_par=0.01, tree_generator=None, lin_trim_quantile=0.025, lin_standardise=True, exp_rand_tree_size=True, include_linear=True, alpha=None, random_state=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Rulefit class. Rather than using this class directly, should use RuleFitRegressor or RuleFitClassifier</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tree_size</code></strong> :&ensp;
<code>Number</code> of <code>terminal</code> <code>nodes</code> <code>in</code> <code>generated</code> <code>trees.</code> <code>If</code> <code>exp_rand_tree_size</code>=<code>True</code>,</dt>
<dd>this will be the mean number of terminal nodes.</dd>
<dt><strong><code>sample_fract</code></strong> :&ensp;
<code>fraction</code> of <code>randomly</code> <code>chosen</code> <code>training</code> <code>observations</code> <code>used</code> <code>to</code> <code>produce</code> <code>each</code> <code>tree.</code></dt>
<dd>FP 2004 (Sec. 2)</dd>
<dt><strong><code>max_rules</code></strong> :&ensp;
<code>total</code> <code>number</code> of <code>terms</code> <code>included</code> <code>in</code> <code>the</code> <code>final</code> <code>model</code> (<code>both</code> <code>linear</code> <code>and</code> <code>rules</code>)</dt>
<dd>approximate total number of candidate rules generated for fitting also is based on this
Note that actual number of candidate rules will usually be lower than this due to duplicates.</dd>
<dt><strong><code>memory_par</code></strong> :&ensp;
<code>scale</code> <code>multiplier</code> (<code>shrinkage</code> <code>factor</code>) <code>applied</code> <code>to</code> <code>each</code> <code>new</code> <code>tree</code> <code>when</code></dt>
<dd>sequentially induced. FP 2004 (Sec. 2)</dd>
<dt><strong><code>lin_standardise</code></strong> :&ensp;<code>If</code> <code>True</code>, <code>the</code> <code>linear</code> <code>terms</code> <code>will</code> <code>be</code> <code>standardised</code> <code>as</code> <code>per</code> <code>Friedman</code> <code>Sec</code> <code>3.2</code></dt>
<dd>by multiplying the winsorised variable by 0.4/stdev.</dd>
<dt><strong><code>lin_trim_quantile</code></strong> :&ensp;<code>If</code> <code>lin_standardise</code> <code>is</code> <code>True</code>, <code>this</code> <code>quantile</code> <code>will</code> <code>be</code> <code>used</code> <code>to</code> <code>trim</code> <code>linear</code></dt>
<dd>terms before standardisation.</dd>
<dt><strong><code>exp_rand_tree_size</code></strong> :&ensp;<code>If</code> <code>True</code>, <code>each</code> <code>boosted</code> <code>tree</code> <code>will</code> <code>have</code> <code>a</code> <code>different</code> <code>maximum</code> <code>number</code> of</dt>
<dd>terminal nodes based on an exponential distribution about tree_size.
(Friedman Sec 3.3)</dd>
<dt><strong><code>include_linear</code></strong> :&ensp;<code>Include</code> <code>linear</code> <code>terms</code> <code>as</code> <code>opposed</code> <code>to</code> <code>only</code> <code>rules</code></dt>
<dd>&nbsp;</dd>
<dt>random_state:
Integer to initialise random objects and provide repeatability.</dt>
<dt><strong><code>tree_generator</code></strong> :&ensp;<code>Optional</code>: <code>this</code> <code>object</code> <code>will</code> <code>be</code> <code>used</code> <code>as</code> <code>provided</code> <code>to</code> <code>generate</code> <code>the</code> <code>rules.</code></dt>
<dd>This will override almost all the other properties above.
Must be GradientBoostingRegressor or GradientBoostingClassifier, optional (default=None)</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>rule_ensemble</code></strong> :&ensp;<code>RuleEnsemble</code></dt>
<dd>The rule ensemble</dd>
<dt><strong><code>feature_names</code></strong> :&ensp;<code>list</code> of <code>strings</code>, optional (default=<code>None</code>)</dt>
<dd>The names of the features (columns)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RuleFitRegressor(RuleFit, RegressorMixin):
    def _init_prediction_task(self):
        self.prediction_task = &#39;regression&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="imodels.rule_set.rule_fit.RuleFit" href="#imodels.rule_set.rule_fit.RuleFit">RuleFit</a></li>
<li>sklearn.base.BaseEstimator</li>
<li>sklearn.base.TransformerMixin</li>
<li><a title="imodels.rule_set.rule_set.RuleSet" href="rule_set.html#imodels.rule_set.rule_set.RuleSet">RuleSet</a></li>
<li>sklearn.base.RegressorMixin</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="imodels.rule_set.rule_fit.RuleFit" href="#imodels.rule_set.rule_fit.RuleFit">RuleFit</a></b></code>:
<ul class="hlist">
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.fit" href="#imodels.rule_set.rule_fit.RuleFit.fit">fit</a></code></li>
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.get_rules" href="#imodels.rule_set.rule_fit.RuleFit.get_rules">get_rules</a></code></li>
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.predict" href="#imodels.rule_set.rule_fit.RuleFit.predict">predict</a></code></li>
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.predict_continuous_output" href="#imodels.rule_set.rule_fit.RuleFit.predict_continuous_output">predict_continuous_output</a></code></li>
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.transform" href="#imodels.rule_set.rule_fit.RuleFit.transform">transform</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="imodels.rule_set" href="index.html">imodels.rule_set</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="imodels.rule_set.rule_fit.RuleFit" href="#imodels.rule_set.rule_fit.RuleFit">RuleFit</a></code></h4>
<ul class="">
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.fit" href="#imodels.rule_set.rule_fit.RuleFit.fit">fit</a></code></li>
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.get_rules" href="#imodels.rule_set.rule_fit.RuleFit.get_rules">get_rules</a></code></li>
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.predict" href="#imodels.rule_set.rule_fit.RuleFit.predict">predict</a></code></li>
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.predict_continuous_output" href="#imodels.rule_set.rule_fit.RuleFit.predict_continuous_output">predict_continuous_output</a></code></li>
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.predict_proba" href="#imodels.rule_set.rule_fit.RuleFit.predict_proba">predict_proba</a></code></li>
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.transform" href="#imodels.rule_set.rule_fit.RuleFit.transform">transform</a></code></li>
<li><code><a title="imodels.rule_set.rule_fit.RuleFit.visualize" href="#imodels.rule_set.rule_fit.RuleFit.visualize">visualize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="imodels.rule_set.rule_fit.RuleFitClassifier" href="#imodels.rule_set.rule_fit.RuleFitClassifier">RuleFitClassifier</a></code></h4>
</li>
<li>
<h4><code><a title="imodels.rule_set.rule_fit.RuleFitRegressor" href="#imodels.rule_set.rule_fit.RuleFitRegressor">RuleFitRegressor</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>