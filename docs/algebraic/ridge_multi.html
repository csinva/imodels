<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<section id="section-intro">
<p>Original code by Alex Huth and Huth lab for predicting fMRI responses
(see <a href="https://github.com/HuthLab/deep-fMRI-dataset/blob/master/encoding/ridge_utils/ridge.py">https://github.com/HuthLab/deep-fMRI-dataset/blob/master/encoding/ridge_utils/ridge.py</a>)</p>
<p>These functions help to predict many outputs using ridge regression efficiently.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;Original code by Alex Huth and Huth lab for predicting fMRI responses
(see https://github.com/HuthLab/deep-fMRI-dataset/blob/master/encoding/ridge_utils/ridge.py)

These functions help to predict many outputs using ridge regression efficiently.
&#39;&#39;&#39;

import time
import numpy as np
from tqdm import tqdm
import logging
import joblib
import itertools as itools
from imodels.algebraic.ridge_multi_utils import mult_diag, _z_score, ridge_logger, _counter
from sklearn.utils.extmath import randomized_svd


def _gen_temporal_chunk_splits(num_splits: int, num_examples: int, chunk_len: int, num_chunks: int, seed=42):
    &#39;&#39;&#39;Make a list of splits for cross-validation, where splits are temporal chunks of data.
    &#39;&#39;&#39;
    rng = np.random.RandomState(seed)
    all_indexes = range(num_examples)
    index_chunks = list(zip(*[iter(all_indexes)] * chunk_len))
    splits_list = []
    for _ in range(num_splits):
        rng.shuffle(index_chunks)
        tune_indexes_ = list(itools.chain(*index_chunks[:num_chunks]))
        train_indexes_ = list(set(all_indexes)-set(tune_indexes_))
        splits_list.append((train_indexes_, tune_indexes_))
    return splits_list


def _ridge(X, y, alpha, singcutoff=1e-10, logger=ridge_logger):
    &#34;&#34;&#34;Uses ridge regression to find a linear transformation of [stim] that approximates
    [resp]. The regularization parameter is [alpha].

    Parameters
    ----------
    X : array_like, shape (n_train, n_features)
    y : array_like, shape (n_train, n_targets)
    alpha : float or array_like, shape (M,)
        Regularization parameter. Can be given as a single value (which is applied to
        all M responses) or separate values for each response.
    normalpha : boolean
        Whether ridge parameters should be normalized by the largest singular value of stim. Good for
        comparing models with different numbers of parameters.

    Returns
    -------
    wt : array_like, shape (N, M)
        Linear regression weights.
    &#34;&#34;&#34;
    # ridge = Ridge(alpha=alpha**2, fit_intercept=False)
    # ridge.fit(X_train, y_train)
    # return ridge.coef_.T

    U, S, Vh = np.linalg.svd(X, full_matrices=False)
    UR = np.dot(U.T, np.nan_to_num(y))

    # Expand alpha to a collection if it&#39;s just a single value
    if isinstance(alpha, (float, int)):
        alpha = np.ones(y.shape[1]) * alpha

    # Normalize alpha by the LSV norm
    nalphas = alpha

    # Compute weights for each alpha
    ualphas = np.unique(nalphas)
    wt = np.zeros((X.shape[1], y.shape[1]))
    for ua in ualphas:
        selvox = np.nonzero(nalphas == ua)[0]
        # awt = reduce(np.dot, [Vh.T, np.diag(S/(S**2+ua**2)), UR[:,selvox]])
        awt = Vh.T.dot(np.diag(S/(S**2+ua**2))).dot(UR[:, selvox])
        wt[:, selvox] = awt

    return wt


def _ridge_correlations_per_voxel(X_train, X_test, y_train, y_test, valphas,
                                  singcutoff=1e-10, use_corr=True, logger=ridge_logger):
    &#34;&#34;&#34;Returns the correlation between y_test and ridge-regression predictions for y_test.
    Never actually needs to compute the regression weights (for speed).
    Assume every target is assigned a separate alpha.

    Parameters
    ----------
    X_train : array_like, shape (n_train, n_features)
    X_test : array_like, shape (n_test, n_features)
    y_train : array_like, shape (n_train, n_targets)
    y_test : array_like, shape (n_test, n_targets)
    valphas : list or array_like, shape (n_targets,)
        Ridge parameter for each voxel.
    corrmin : float in [0..1]
        Purely for display purposes. After each alpha is tested, the number of responses with correlation
        greater than corrmin minus the number of responses with correlation less than negative corrmin
        will be printed. For long-running regressions this vague metric of non-centered skewness can
        give you a rough sense of how well the model is working before it&#39;s done.
    singcutoff : float
        The first step in ridge regression is computing the singular value decomposition (SVD) of the
        stimulus Rstim. If Rstim is not full rank, some singular values will be approximately equal
        to zero and the corresponding singular vectors will be noise. These singular values/vectors
        should be removed both for speed (the fewer multiplications the better!) and accuracy. Any
        singular values less than singcutoff will be removed.
    use_corr : boolean
        If True, this function will use correlation as its metric of model fit. If False, this function
        will instead use variance explained (R-squared) as its metric of model fit. For ridge regression
        this can make a big difference -- highly regularized solutions will have very small norms and
        will thus explain very little variance while still leading to high correlations, as correlation
        is scale-free while R**2 is not.

    Returns
    -------
    corr : array_like, shape (n_targets,)
        The correlation between each predicted response and each column of Presp.

    &#34;&#34;&#34;
    # Calculate SVD of stimulus matrix
    logger.info(&#34;Doing SVD...&#34;)
    U, S, Vh = np.linalg.svd(X_train, full_matrices=False)

    # Truncate tiny singular values for speed
    origsize = S.shape[0]
    ngoodS = np.sum(S &gt; singcutoff)
    nbad = origsize-ngoodS
    U = U[:, :ngoodS]
    S = S[:ngoodS]
    Vh = Vh[:ngoodS]
    logger.info(&#34;Dropped %d tiny singular values.. (U is now %s)&#34; %
                (nbad, str(U.shape)))

    # Precompute some products for speed
    UR = np.dot(U.T, y_train)  # Precompute this matrix product for speed
    PVh = np.dot(X_test, Vh.T)  # Precompute this matrix product for speed

    # Prespnorms = np.apply_along_axis(np.linalg.norm, 0, Presp) ## Precompute test response norms
    y_test_normalized = _z_score(y_test)
    # y_test_var = Presp.var(0)
    y_test_var_actual = y_test.var(0)
    y_test_var = (np.ones_like(y_test_var_actual) + y_test_var_actual) / 2.0
    logger.info(&#34;Average difference between actual &amp; assumed y_test_var: %0.3f&#34; % (
        y_test_var_actual - y_test_var).mean())

    ualphas = np.unique(valphas)
    corr = np.zeros((y_train.shape[1],))
    for ua in ualphas:
        selvox = np.nonzero(valphas == ua)[0]
        alpha_pred = PVh.dot(np.diag(S/(S**2+ua**2))).dot(UR[:, selvox])

        if use_corr:
            corr[selvox] = (y_test_normalized[:, selvox]
                            * _z_score(alpha_pred)).mean(0)
        else:
            resvar = (y_test[:, selvox] - alpha_pred).var(0)
            Rsq = 1 - (resvar / y_test_var)
            corr[selvox] = np.sqrt(np.abs(Rsq)) * np.sign(Rsq)

    return corr


def _ridge_correlations_per_voxel_per_alpha(
    X_train, X_test, y_train, y_test, alphas, corrmin=0.2,
        singcutoff=1e-10, use_corr=True, logger=ridge_logger):
    &#34;&#34;&#34;Uses ridge regression to find a linear transformation of [Rstim] that approximates [Rresp],
    then tests by comparing the transformation of [Pstim] to [Presp]. This procedure is repeated
    for each regularization parameter alpha in [alphas]. The correlation between each prediction and
    each response for each alpha is returned. The regression weights are NOT returned, because
    computing the correlations without computing regression weights is much, MUCH faster.

    Assumes features are Z-scored across time.

    Parameters
    ----------
    X_train : array_like, shape (n_train, n_features)
    X_test : array_like, shape (n_test, n_features)
    y_train : array_like, shape (n_train, n_targets)
    y_test : array_like, shape (n_test, n_targets)
    alphas : list or array_like, shape (n_alphas,)
        Ridge parameters to be tested. Should probably be log-spaced. np.logspace(0, 3, 20) works well.
    corrmin : float in [0..1]
        Purely for display purposes. After each alpha is tested, the number of responses with correlation
        greater than corrmin minus the number of responses with correlation less than negative corrmin
        will be printed. For long-running regressions this vague metric of non-centered skewness can
        give you a rough sense of how well the model is working before it&#39;s done.
    singcutoff : float
        The first step in ridge regression is computing the singular value decomposition (SVD) of the
        stimulus Rstim. If Rstim is not full rank, some singular values will be approximately equal
        to zero and the corresponding singular vectors will be noise. These singular values/vectors
        should be removed both for speed (the fewer multiplications the better!) and accuracy. Any
        singular values less than singcutoff will be removed.
    use_corr : boolean
        If True, this function will use correlation as its metric of model fit. If False, this function
        will instead use variance explained (R-squared) as its metric of model fit. For ridge regression
        this can make a big difference -- highly regularized solutions will have very small norms and
        will thus explain very little variance while still leading to high correlations, as correlation
        is scale-free while R**2 is not.

    Returns
    -------
    y_corrs : array_like, shape (n_alphas, n_targets)
        The correlation between each predicted response and each column of y_test for each alpha.

    &#34;&#34;&#34;
    # Calculate SVD of stimulus matrix
    logger.debug(&#34;Doing SVD...&#34;)
    U, S, Vh = np.linalg.svd(X_train, full_matrices=False)

    # Truncate tiny singular values for speed
    origsize = S.shape[0]
    ngoodS = np.sum(S &gt; singcutoff)
    nbad = origsize-ngoodS
    U = U[:, :ngoodS]
    S = S[:ngoodS]
    Vh = Vh[:ngoodS]
    logger.debug(&#34;Dropped %d tiny singular values.. (U is now %s)&#34; %
                 (nbad, str(U.shape)))

    # Precompute some products for speed
    UR = np.dot(U.T, y_train)  # Precompute this matrix product for speed
    PVh = np.dot(X_test, Vh.T)  # Precompute this matrix product for speed

    # Prespnorms = np.apply_along_axis(np.linalg.norm, 0, Presp) ## Precompute test response norms
    y_test_normalized = _z_score(y_test)
    # y_test_var = Presp.var(0)
    y_test_var_actual = y_test.var(0)
    y_test_var = (np.ones_like(y_test_var_actual) + y_test_var_actual) / 2.0
    logger.debug(&#34;Average difference between actual &amp; assumed y_test_var: %0.3f&#34; % (
        y_test_var_actual - y_test_var).mean())
    Rcorrs = []  # Holds training correlations for each alpha
    for na, a in zip(alphas, alphas):
        # Reweight singular vectors by the (normalized?) ridge parameter
        D = S / (S ** 2 + na ** 2)

        pred = np.dot(mult_diag(D, PVh, left=False), UR)

        if use_corr:
            Rcorr = (y_test_normalized * _z_score(pred)).mean(0)
        else:
            # Compute variance explained
            resvar = (y_test - pred).var(0)
            Rsq = 1 - (resvar / y_test_var)
            Rcorr = np.sqrt(np.abs(Rsq)) * np.sign(Rsq)

        Rcorr[np.isnan(Rcorr)] = 0
        Rcorrs.append(Rcorr)

        log_template = &#34;Training: alpha=%0.3f, mean corr=%0.5f, max corr=%0.5f, over-under(%0.2f)=%d&#34;
        log_msg = log_template % (a,
                                  np.mean(Rcorr),
                                  np.max(Rcorr),
                                  corrmin,
                                  (Rcorr &gt; corrmin).sum()-(-Rcorr &gt; corrmin).sum())
        logger.debug(log_msg)

    return Rcorrs


def bootstrap_ridge(
        X_train, y_train, X_test, y_test, alphas, nboots, chunklen, nchunks,
        corrmin=0.2, joined=None, singcutoff=1e-10, single_alpha=False,
        use_corr=True, return_wt=True, logger=ridge_logger, decrease_alpha: int = 0):
    &#34;&#34;&#34;Uses ridge regression with a bootstrapped held-out set to get optimal alpha values for each response.

    First, [nchunks] random chunks of length [chunklen] will be taken from [X_train] and [y_train] for each regression
    run.  [nboots] total regression runs will be performed.  The best alpha value for each response will be
    averaged across the bootstraps to estimate the best alpha for that response.

    If [joined] is given, it should be a list of lists where the STRFs for all the voxels in each sublist 
    will be given the same regularization parameter (the one that is the best on average).

    Parameters
    ----------
    X_train : array_like, shape (n_train, n_features)
    X_test : array_like, shape (n_test, n_features)
    y_train : array_like, shape (n_train, n_targets)
    y_test : array_like, shape (n_test, n_targets)
    alphas : list or array_like, shape (A,)
        Ridge parameters that will be tested. Should probably be log-spaced. np.logspace(0, 3, 20) works well.
    nboots : int
        The number of bootstrap samples to run. 15 to 30 works well.
    chunklen : int
        On each sample, the training data is broken into chunks of this length. This should be a few times 
        longer than your delay/STRF. e.g. for a STRF with 3 delays, I use chunks of length 10.
    nchunks : int
        The number of training chunks held out to test ridge parameters for each bootstrap sample. The product
        of nchunks and chunklen is the total number of training samples held out for each sample, and this 
        product should be about 20 percent of the total length of the training data.
    corrmin : float in [0..1], default 0.2
        Purely for display purposes. After each alpha is tested for each bootstrap sample, the number of 
        responses with correlation greater than this value will be printed. For long-running regressions this
        can give a rough sense of how well the model works before it&#39;s done.
    joined : None or list of array_like indices, default None
        If you want the STRFs for two (or more) responses to be directly comparable, you need to ensure that
        the regularization parameter that they use is the same. To do that, supply a list of the response sets
        that should use the same ridge parameter here. For example, if you have four responses, joined could
        be [np.array([0,1]), np.array([2,3])], in which case responses 0 and 1 will use the same ridge parameter
        (which will be parameter that is best on average for those two), and likewise for responses 2 and 3.
    singcutoff : float, default 1e-10
        The first step in ridge regression is computing the singular value decomposition (SVD) of the
        stimulus Rstim. If Rstim is not full rank, some singular values will be approximately equal
        to zero and the corresponding singular vectors will be noise. These singular values/vectors
        should be removed both for speed (the fewer multiplications the better!) and accuracy. Any
        singular values less than singcutoff will be removed.
    single_alpha : boolean, default False
        Whether to use a single alpha for all responses. Good for identification/decoding.
    use_corr : boolean, default True
        If True, this function will use correlation as its metric of model fit. If False, this function
        will instead use variance explained (R-squared) as its metric of model fit. For ridge regression
        this can make a big difference -- highly regularized solutions will have very small norms and
        will thus explain very little variance while still leading to high correlations, as correlation
        is scale-free while R**2 is not.
    return_wt : boolean, default True
        If True, this function will compute and return the regression weights after finding the best
        alpha parameter for each voxel. However, for very large models this can lead to memory issues.
        If false, this function will _not_ compute weights, but will still compute prediction performance
        on the prediction dataset (Pstim, Presp).

    Returns
    -------
    wt : array_like, shape (N, M)
        If [return_wt] is True, regression weights for N features and M responses. If [return_wt] is False, [].
    corrs : array_like, shape (M,)
        Validation set correlations. Predicted responses for the validation set are obtained using the regression
        weights: pred = np.dot(Pstim, wt), and then the correlation between each predicted response and each 
        column in Presp is found.
    alphas : array_like, shape (M,)
        The regularization coefficient (alpha) selected for each voxel using bootstrap cross-validation.
    bootstrap_corrs : array_like, shape (A, M, B)
        Correlation between predicted and actual responses on randomly held out portions of the training set,
        for each of A alphas, M voxels, and B bootstrap samples.
    valinds : array_like, shape (TH, B)
        The indices of the training data that were used as &#34;validation&#34; for each bootstrap sample.
    &#34;&#34;&#34;
    n_train, n_targets = y_train.shape
    splits = _gen_temporal_chunk_splits(
        nboots, n_train, chunklen, nchunks)
    valinds = [splits[1] for splits in splits]

    correlation_matrices = []
    for idx_bootstrap in _counter(range(nboots), countevery=1, total=nboots):
        logger.debug(&#34;Selecting held-out test set..&#34;)

        # get indices for training / testing
        train_indexes_, tune_indexes_ = splits[idx_bootstrap]

        # Select data
        X_train_ = X_train[train_indexes_, :]
        X_tune_ = X_train[tune_indexes_, :]
        y_train_ = y_train[train_indexes_, :]
        y_tune_ = y_train[tune_indexes_, :]

        # Run ridge regression using this test set
        correlation_matrix_ = _ridge_correlations_per_voxel_per_alpha(
            X_train_, X_tune_, y_train_, y_tune_, alphas,
            corrmin=corrmin, singcutoff=singcutoff,
            use_corr=use_corr,
            logger=logger)
        correlation_matrices.append(correlation_matrix_)

    # Find best alphas
    if nboots &gt; 0:
        all_correlation_matrices = np.dstack(correlation_matrices)
    else:
        all_correlation_matrices = None

    if not single_alpha:
        if nboots == 0:
            raise ValueError(&#34;You must run at least one cross-validation step to assign &#34;
                             &#34;different alphas to each response.&#34;)

        logger.info(&#34;Finding best alpha for each voxel..&#34;)
        if joined is None:
            # Find best alpha for each voxel
            meanbootcorrs = all_correlation_matrices.mean(2)
            bestalphainds = np.argmax(meanbootcorrs, 0)

            # decrease inds by one clipped at max index
            if decrease_alpha &gt; 0:
                print(&#39;decrease alpha mean&#39;, np.mean(bestalphainds))
                bestalphainds = np.clip(
                    bestalphainds - decrease_alpha, 0, len(alphas)-1)
                print(&#39;decrease alpha mean&#39;, np.mean(bestalphainds))
            valphas = alphas[bestalphainds]

        else:
            # Find best alpha for each group of voxels
            valphas = np.zeros((n_targets,))
            for jl in joined:
                # Mean across voxels in the set, then mean across bootstraps
                jcorrs = all_correlation_matrices[:, jl, :].mean(1).mean(1)
                bestalpha = np.argmax(jcorrs)
                valphas[jl] = alphas[bestalpha]
    else:
        logger.debug(&#34;Finding single best alpha..&#34;)
        if nboots == 0:
            if len(alphas) == 1:
                bestalphaind = 0
                bestalpha = alphas[0]
            else:
                raise ValueError(&#34;You must run at least one cross-validation step &#34;
                                 &#34;to choose best overall alpha, or only supply one&#34;
                                 &#34;possible alpha value.&#34;)
        else:
            meanbootcorr = all_correlation_matrices.mean(2).mean(1)
            bestalphaind = np.argmax(meanbootcorr)
            bestalpha = alphas[bestalphaind]

        valphas = np.array([bestalpha]*n_targets)
        logger.debug(&#34;Best alpha = %0.3f&#34; % bestalpha)

    if return_wt:
        # Find weights
        logger.debug(
            &#34;Computing weights for each response using entire training set..&#34;)
        # wt = _ridge_sklearn(X_train, y_train, valphas)
        wt = _ridge(X_train, y_train, valphas, singcutoff=singcutoff)

        # Predict responses on prediction set
        logger.debug(&#34;Predicting responses for predictions set..&#34;)
        pred = np.dot(X_test, wt)

        # Find prediction correlations
        nnpred = np.nan_to_num(pred)
        if use_corr:
            corrs_test = np.nan_to_num(np.array([np.corrcoef(y_test[:, ii], nnpred[:, ii].ravel())[0, 1]
                                                 for ii in range(y_test.shape[1])]))
        else:
            residual_variance = (y_test-pred).var(0)
            residual_sum_of_squares = 1 - \
                (residual_variance / y_test.var(0))
            corrs_test = np.sqrt(np.abs(residual_sum_of_squares)) * \
                np.sign(residual_sum_of_squares)

        return wt, corrs_test, valphas, all_correlation_matrices, valinds
    else:
        # get correlations for prediction dataset directly
        corrs_test = _ridge_correlations_per_voxel(
            X_train, X_test, y_train, X_test, valphas,
            use_corr=use_corr, logger=logger, singcutoff=singcutoff)

        return [], corrs_test, valphas, all_correlation_matrices, valinds


def lowrank_ridge(X, Y, alpha, r):
    &#34;&#34;&#34;
    Perform ridge regression with many inputs and outputs using a rank-r approximation.

    Parameters:
    X : numpy.ndarray
        Input features matrix of shape (n_samples, n_features).
    Y : numpy.ndarray
        Output targets matrix of shape (n_samples, n_outputs).
    alpha : float
        Regularization parameter (alphaa).
    r : int
        Rank for the truncated SVD.

    Returns:
    B : numpy.ndarray
        Coefficient matrix of shape (n_features, n_outputs).
    &#34;&#34;&#34;
    # Step 1: Compute truncated SVD of X
    U_r, Sigma_r, V_r_T = randomized_svd(X, n_components=r)

    # Step 2: Compute T = U_r^T Y
    T = U_r.T @ Y  # Shape: (r, n_outputs)

    # Step 3: Compute D = (Σ_r^2 + λ I_r)^{-1} Σ_r
    denom = Sigma_r ** 2 + alpha
    D = Sigma_r / denom  # Shape: (r,)

    # Step 4: Compute B ≈ V_r D T
    DT = D[:, np.newaxis] * T  # Element-wise multiplication
    B = V_r_T.T @ DT  # Shape: (n_features, n_outputs)

    return B


def bootstrap_low_rank_ridge(
        X_train, y_train, alphas, ranks, nboots, chunklen, nchunks,
        logger=ridge_logger):

    n_train, n_targets = y_train.shape
    splits = _gen_temporal_chunk_splits(
        nboots, n_train, chunklen, nchunks)
    valinds = [splits[1] for splits in splits]

    correlation_matrices = []
    for idx_bootstrap in _counter(range(nboots), countevery=1, total=nboots):
        logger.debug(&#34;Selecting held-out test set..&#34;)

        # get indices for training / testing
        train_indexes_, tune_indexes_ = splits[idx_bootstrap]

        # Select data
        X_train_ = X_train[train_indexes_, :]
        X_tune_ = X_train[tune_indexes_, :]
        y_train_ = y_train[train_indexes_, :]
        y_tune_ = y_train[tune_indexes_, :]

        # Run ridge regression using this test set
        t0 = time.time()
        correlation_matrix = np.zeros((len(ranks), len(alphas), n_targets))
        for i, rank in enumerate(ranks):
            for j, alpha in enumerate(tqdm(alphas)):
                wt = lowrank_ridge(X_train_, y_train_, alpha, rank)
                pred_tune = X_tune_ @ wt
                correlation_matrix[i, j] = np.array([np.corrcoef(y_tune_[:, ii], pred_tune[:, ii].ravel())[0, 1]
                                                     for ii in range(y_tune_.shape[1])])

        correlation_matrices.append(correlation_matrix.reshape(-1, n_targets))

    # Find best settings for each voxel
    all_correlation_matrices = np.dstack(correlation_matrices)
    meanbootcorrs = all_correlation_matrices.mean(2)
    best_indexes = np.argmax(meanbootcorrs, 0)

    # Fit full model for everything
    wts_full = []
    for i, rank in enumerate(ranks):
        for j, alpha in enumerate(tqdm(alphas)):
            wts_full.append(lowrank_ridge(
                X_train, y_train, alpha, rank))

    # select best weight per voxel
    wts_final = np.zeros_like(wts_full[0])
    for i in tqdm(range(n_targets)):
        wts_final[:, i] = wts_full[best_indexes[i]][:, i]
    logger.debug(f&#34;\ttime elapsed: {time.time()-t0}&#34;)

    return wts_final, meanbootcorrs


def boostrap_ridge_with_lowrank(
        X_train, y_train, X_test, y_test, alphas_ridge, alphas_lowrank,
        ranks, nboots, chunklen, nchunks,
        singcutoff=1e-10, single_alpha=False, logger=ridge_logger
):
    wt_ridge, corrs_test, alphas_best, corrs_tune, valinds = bootstrap_ridge(
        X_train, y_train, X_test, y_test,
        alphas=alphas_ridge,
        nboots=nboots,
        chunklen=chunklen, nchunks=nchunks,
        singcutoff=singcutoff, single_alpha=single_alpha, logger=logger)

    # pred_test = X_test @ wt_ridge
    # corrs_test = np.array([np.corrcoef(y_test[:, ii], pred_test[:, ii].ravel())[0, 1]
    #    for ii in range(y_test.shape[1])])
    logger.debug(f&#39;mean test corrs ridge {corrs_test.mean():.5f}&#39;)

    wt_lowrank, meanbootcorrs = bootstrap_low_rank_ridge(
        X_train, y_train, alphas=alphas_lowrank, ranks=ranks,
        nboots=nboots, chunklen=chunklen, nchunks=nchunks, logger=logger)
    pred_test = X_test @ wt_lowrank
    corrs_test = np.array([np.corrcoef(y_test[:, ii], pred_test[:, ii].ravel())[0, 1]
                           for ii in range(y_test.shape[1])])
    # print(&#39;mean test corrs&#39;, corrs_test.mean())
    logger.debug(f&#39;mean test corrs lowrank {corrs_test.mean():.5f}&#39;)

    # select best weights based on bootstrap results
    mean_boot_corrs_ridge = corrs_tune.mean(2).max(axis=0)
    mean_boot_corrs_lowrank = meanbootcorrs.max(axis=0)
    wt_hybrid = np.zeros_like(wt_ridge)
    for i in range(y_train.shape[1]):
        if mean_boot_corrs_ridge[i] &gt; mean_boot_corrs_lowrank[i]:
            wt_hybrid[:, i] = wt_ridge[:, i]
        else:
            wt_hybrid[:, i] = wt_lowrank[:, i]

    pred_test = X_test @ wt_hybrid
    corrs_test = np.array([np.corrcoef(y_test[:, ii], pred_test[:, ii].ravel())[0, 1]
                           for ii in range(y_test.shape[1])])
    logger.debug(f&#39;mean test corrs hybrid {corrs_test.mean():.5f}&#39;)
    corrs_tune = np.maximum(mean_boot_corrs_ridge, mean_boot_corrs_lowrank)

    return wt_hybrid, corrs_test, corrs_tune, valinds


    ###########################################################
if __name__ == &#39;__main__&#39;:
    # sample data for ridge regression
    np.random.seed(0)

    # set logging to debug
    logging.basicConfig(level=logging.DEBUG)

    # params = joblib.load(&#39;example_params.joblib&#39;)
    params = joblib.load(&#39;/home/chansingh/fmri/example_params_full.joblib&#39;)
    print(params.keys())

    X_train = params[&#39;features_train_delayed&#39;]
    y_train = params[&#39;resp_train&#39;]
    X_test = params[&#39;features_test_delayed&#39;]
    y_test = params[&#39;resp_test&#39;]
    alphas = params[&#39;alphas&#39;]
    # nboots=params[&#39;nboots&#39;],
    nboots = 10
    chunklen = params[&#39;chunklen&#39;]
    nchunks = params[&#39;nchunks&#39;]
    singcutoff = params[&#39;singcutoff&#39;]
    single_alpha = params[&#39;single_alpha&#39;]

    # wt_hybrid, corrs_test, corrs_tune, valinds = boostrap_ridge_with_lowrank(
    #     X_train, y_train, X_test, y_test,
    #     alphas_ridge=alphas,
    #     alphas_lowrank=alphas,
    #     ranks=[100],
    #     nboots=nboots, chunklen=chunklen, nchunks=nchunks)

    print(&#39;alphas&#39;, alphas)

    # baseline call (with decrease_alpha=1)
    t0 = time.time()
    wt_ridge, corrs_test, alphas_best, corrs_tune, valinds = bootstrap_ridge(
        X_train, y_train, X_test, y_test,
        alphas=alphas,
        nboots=nboots,
        chunklen=params[&#39;chunklen&#39;], nchunks=params[&#39;nchunks&#39;],
        singcutoff=params[&#39;singcutoff&#39;], single_alpha=params[&#39;single_alpha&#39;],
        decrease_alpha=1
    )
    print(&#39;time elapsed&#39;, time.time()-t0)

    pred_test = X_test @ wt_ridge
    corrs_test = np.array([np.corrcoef(y_test[:, ii], pred_test[:, ii].ravel())[0, 1]
                           for ii in range(y_test.shape[1])])
    print(&#39;mean test corrs&#39;, corrs_test.mean())
    pred_train = X_train @ wt_ridge
    corrs_train = np.array([np.corrcoef(y_train[:, ii], pred_train[:, ii].ravel())[0, 1]
                            for ii in range(y_train.shape[1])])
    print(&#39;mean train corrs&#39;, corrs_train.mean())

    # # call 2
    # t0 = time.time()
    # wt_lowrank, meanbootcorrs = bootstrap_low_rank_ridge(
    #     X_train, y_train, alphas=alphas[::2], ranks=[25, 100], nboots=nboots, chunklen=chunklen, nchunks=nchunks)
    # print(&#39;time elapsed&#39;, time.time()-t0)
    # pred_train = X_train @ wt_lowrank

    # pred_test = X_test @ wt_lowrank
    # corrs_test = np.array([np.corrcoef(y_test[:, ii], pred_test[:, ii].ravel())[0, 1]
    #                        for ii in range(y_test.shape[1])])
    # print(&#39;mean test corrs&#39;, corrs_test.mean())
    # pred_train = X_train @ wt_lowrank
    # corrs_train = np.array([np.corrcoef(y_train[:, ii], pred_train[:, ii].ravel())[0, 1]
    #                         for ii in range(y_train.shape[1])])
    # print(&#39;mean train corrs&#39;, corrs_train.mean())

    # # select weights between wt and wt_lowrank based on bootstrap results
    # try:
    #     meanbootcorrs_ridge = corrs_tune.mean(2).max(axis=0)
    #     meanbootcorrs_lowrank = meanbootcorrs.max(axis=0)
    #     wt_hybrid = np.zeros_like(wt_ridge)
    #     for i in range(y_train.shape[1]):
    #         if meanbootcorrs_ridge[i] &gt; meanbootcorrs_lowrank[i]:
    #             wt_hybrid[:, i] = wt_ridge[:, i]
    #         else:
    #             wt_hybrid[:, i] = wt_lowrank[:, i]

    #     pred_test = X_test @ wt_hybrid
    #     corrs_test = np.array([np.corrcoef(y_test[:, ii], pred_test[:, ii].ravel())[0, 1]
    #                            for ii in range(y_test.shape[1])])
    #     print(&#39;mean test corrs&#39;, corrs_test.mean())
    #     pred_train = X_train @ wt_hybrid
    #     corrs_train = np.array([np.corrcoef(y_train[:, ii], pred_train[:, ii].ravel())[0, 1]
    #                             for ii in range(y_train.shape[1])])
    #     print(&#39;mean train corrs&#39;, corrs_train.mean())
    # except Exception as e:
    #     print(e)
    #     breakpoint()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="imodels.algebraic.ridge_multi.boostrap_ridge_with_lowrank"><code class="name flex">
<span>def <span class="ident">boostrap_ridge_with_lowrank</span></span>(<span>X_train, y_train, X_test, y_test, alphas_ridge, alphas_lowrank, ranks, nboots, chunklen, nchunks, singcutoff=1e-10, single_alpha=False, logger=&lt;Logger ridge_corr (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boostrap_ridge_with_lowrank(
        X_train, y_train, X_test, y_test, alphas_ridge, alphas_lowrank,
        ranks, nboots, chunklen, nchunks,
        singcutoff=1e-10, single_alpha=False, logger=ridge_logger
):
    wt_ridge, corrs_test, alphas_best, corrs_tune, valinds = bootstrap_ridge(
        X_train, y_train, X_test, y_test,
        alphas=alphas_ridge,
        nboots=nboots,
        chunklen=chunklen, nchunks=nchunks,
        singcutoff=singcutoff, single_alpha=single_alpha, logger=logger)

    # pred_test = X_test @ wt_ridge
    # corrs_test = np.array([np.corrcoef(y_test[:, ii], pred_test[:, ii].ravel())[0, 1]
    #    for ii in range(y_test.shape[1])])
    logger.debug(f&#39;mean test corrs ridge {corrs_test.mean():.5f}&#39;)

    wt_lowrank, meanbootcorrs = bootstrap_low_rank_ridge(
        X_train, y_train, alphas=alphas_lowrank, ranks=ranks,
        nboots=nboots, chunklen=chunklen, nchunks=nchunks, logger=logger)
    pred_test = X_test @ wt_lowrank
    corrs_test = np.array([np.corrcoef(y_test[:, ii], pred_test[:, ii].ravel())[0, 1]
                           for ii in range(y_test.shape[1])])
    # print(&#39;mean test corrs&#39;, corrs_test.mean())
    logger.debug(f&#39;mean test corrs lowrank {corrs_test.mean():.5f}&#39;)

    # select best weights based on bootstrap results
    mean_boot_corrs_ridge = corrs_tune.mean(2).max(axis=0)
    mean_boot_corrs_lowrank = meanbootcorrs.max(axis=0)
    wt_hybrid = np.zeros_like(wt_ridge)
    for i in range(y_train.shape[1]):
        if mean_boot_corrs_ridge[i] &gt; mean_boot_corrs_lowrank[i]:
            wt_hybrid[:, i] = wt_ridge[:, i]
        else:
            wt_hybrid[:, i] = wt_lowrank[:, i]

    pred_test = X_test @ wt_hybrid
    corrs_test = np.array([np.corrcoef(y_test[:, ii], pred_test[:, ii].ravel())[0, 1]
                           for ii in range(y_test.shape[1])])
    logger.debug(f&#39;mean test corrs hybrid {corrs_test.mean():.5f}&#39;)
    corrs_tune = np.maximum(mean_boot_corrs_ridge, mean_boot_corrs_lowrank)

    return wt_hybrid, corrs_test, corrs_tune, valinds


    ###########################################################</code></pre>
</details>
</dd>
<dt id="imodels.algebraic.ridge_multi.bootstrap_low_rank_ridge"><code class="name flex">
<span>def <span class="ident">bootstrap_low_rank_ridge</span></span>(<span>X_train, y_train, alphas, ranks, nboots, chunklen, nchunks, logger=&lt;Logger ridge_corr (WARNING)&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bootstrap_low_rank_ridge(
        X_train, y_train, alphas, ranks, nboots, chunklen, nchunks,
        logger=ridge_logger):

    n_train, n_targets = y_train.shape
    splits = _gen_temporal_chunk_splits(
        nboots, n_train, chunklen, nchunks)
    valinds = [splits[1] for splits in splits]

    correlation_matrices = []
    for idx_bootstrap in _counter(range(nboots), countevery=1, total=nboots):
        logger.debug(&#34;Selecting held-out test set..&#34;)

        # get indices for training / testing
        train_indexes_, tune_indexes_ = splits[idx_bootstrap]

        # Select data
        X_train_ = X_train[train_indexes_, :]
        X_tune_ = X_train[tune_indexes_, :]
        y_train_ = y_train[train_indexes_, :]
        y_tune_ = y_train[tune_indexes_, :]

        # Run ridge regression using this test set
        t0 = time.time()
        correlation_matrix = np.zeros((len(ranks), len(alphas), n_targets))
        for i, rank in enumerate(ranks):
            for j, alpha in enumerate(tqdm(alphas)):
                wt = lowrank_ridge(X_train_, y_train_, alpha, rank)
                pred_tune = X_tune_ @ wt
                correlation_matrix[i, j] = np.array([np.corrcoef(y_tune_[:, ii], pred_tune[:, ii].ravel())[0, 1]
                                                     for ii in range(y_tune_.shape[1])])

        correlation_matrices.append(correlation_matrix.reshape(-1, n_targets))

    # Find best settings for each voxel
    all_correlation_matrices = np.dstack(correlation_matrices)
    meanbootcorrs = all_correlation_matrices.mean(2)
    best_indexes = np.argmax(meanbootcorrs, 0)

    # Fit full model for everything
    wts_full = []
    for i, rank in enumerate(ranks):
        for j, alpha in enumerate(tqdm(alphas)):
            wts_full.append(lowrank_ridge(
                X_train, y_train, alpha, rank))

    # select best weight per voxel
    wts_final = np.zeros_like(wts_full[0])
    for i in tqdm(range(n_targets)):
        wts_final[:, i] = wts_full[best_indexes[i]][:, i]
    logger.debug(f&#34;\ttime elapsed: {time.time()-t0}&#34;)

    return wts_final, meanbootcorrs</code></pre>
</details>
</dd>
<dt id="imodels.algebraic.ridge_multi.bootstrap_ridge"><code class="name flex">
<span>def <span class="ident">bootstrap_ridge</span></span>(<span>X_train, y_train, X_test, y_test, alphas, nboots, chunklen, nchunks, corrmin=0.2, joined=None, singcutoff=1e-10, single_alpha=False, use_corr=True, return_wt=True, logger=&lt;Logger ridge_corr (WARNING)&gt;, decrease_alpha: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses ridge regression with a bootstrapped held-out set to get optimal alpha values for each response.</p>
<p>First, [nchunks] random chunks of length [chunklen] will be taken from [X_train] and [y_train] for each regression
run.
[nboots] total regression runs will be performed.
The best alpha value for each response will be
averaged across the bootstraps to estimate the best alpha for that response.</p>
<p>If [joined] is given, it should be a list of lists where the STRFs for all the voxels in each sublist
will be given the same regularization parameter (the one that is the best on average).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X_train</code></strong> :&ensp;<code>array_like, shape (n_train, n_features)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>X_test</code></strong> :&ensp;<code>array_like, shape (n_test, n_features)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y_train</code></strong> :&ensp;<code>array_like, shape (n_train, n_targets)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y_test</code></strong> :&ensp;<code>array_like, shape (n_test, n_targets)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>alphas</code></strong> :&ensp;<code>list</code> or <code>array_like, shape (A,)</code></dt>
<dd>Ridge parameters that will be tested. Should probably be log-spaced. np.logspace(0, 3, 20) works well.</dd>
<dt><strong><code>nboots</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of bootstrap samples to run. 15 to 30 works well.</dd>
<dt><strong><code>chunklen</code></strong> :&ensp;<code>int</code></dt>
<dd>On each sample, the training data is broken into chunks of this length. This should be a few times
longer than your delay/STRF. e.g. for a STRF with 3 delays, I use chunks of length 10.</dd>
<dt><strong><code>nchunks</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of training chunks held out to test ridge parameters for each bootstrap sample. The product
of nchunks and chunklen is the total number of training samples held out for each sample, and this
product should be about 20 percent of the total length of the training data.</dd>
<dt><strong><code>corrmin</code></strong> :&ensp;<code>float in [0..1]</code>, default <code>0.2</code></dt>
<dd>Purely for display purposes. After each alpha is tested for each bootstrap sample, the number of
responses with correlation greater than this value will be printed. For long-running regressions this
can give a rough sense of how well the model works before it's done.</dd>
<dt><strong><code>joined</code></strong> :&ensp;<code>None</code> or <code>list</code> of <code>array_like indices</code>, default <code>None</code></dt>
<dd>If you want the STRFs for two (or more) responses to be directly comparable, you need to ensure that
the regularization parameter that they use is the same. To do that, supply a list of the response sets
that should use the same ridge parameter here. For example, if you have four responses, joined could
be [np.array([0,1]), np.array([2,3])], in which case responses 0 and 1 will use the same ridge parameter
(which will be parameter that is best on average for those two), and likewise for responses 2 and 3.</dd>
<dt><strong><code>singcutoff</code></strong> :&ensp;<code>float</code>, default <code>1e-10</code></dt>
<dd>The first step in ridge regression is computing the singular value decomposition (SVD) of the
stimulus Rstim. If Rstim is not full rank, some singular values will be approximately equal
to zero and the corresponding singular vectors will be noise. These singular values/vectors
should be removed both for speed (the fewer multiplications the better!) and accuracy. Any
singular values less than singcutoff will be removed.</dd>
<dt><strong><code>single_alpha</code></strong> :&ensp;<code>boolean</code>, default <code>False</code></dt>
<dd>Whether to use a single alpha for all responses. Good for identification/decoding.</dd>
<dt><strong><code>use_corr</code></strong> :&ensp;<code>boolean</code>, default <code>True</code></dt>
<dd>If True, this function will use correlation as its metric of model fit. If False, this function
will instead use variance explained (R-squared) as its metric of model fit. For ridge regression
this can make a big difference &ndash; highly regularized solutions will have very small norms and
will thus explain very little variance while still leading to high correlations, as correlation
is scale-free while R**2 is not.</dd>
<dt><strong><code>return_wt</code></strong> :&ensp;<code>boolean</code>, default <code>True</code></dt>
<dd>If True, this function will compute and return the regression weights after finding the best
alpha parameter for each voxel. However, for very large models this can lead to memory issues.
If false, this function will <em>not</em> compute weights, but will still compute prediction performance
on the prediction dataset (Pstim, Presp).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>wt</code></strong> :&ensp;<code>array_like, shape (N, M)</code></dt>
<dd>If [return_wt] is True, regression weights for N features and M responses. If [return_wt] is False, [].</dd>
<dt><strong><code>corrs</code></strong> :&ensp;<code>array_like, shape (M,)</code></dt>
<dd>Validation set correlations. Predicted responses for the validation set are obtained using the regression
weights: pred = np.dot(Pstim, wt), and then the correlation between each predicted response and each
column in Presp is found.</dd>
<dt><strong><code>alphas</code></strong> :&ensp;<code>array_like, shape (M,)</code></dt>
<dd>The regularization coefficient (alpha) selected for each voxel using bootstrap cross-validation.</dd>
<dt><strong><code>bootstrap_corrs</code></strong> :&ensp;<code>array_like, shape (A, M, B)</code></dt>
<dd>Correlation between predicted and actual responses on randomly held out portions of the training set,
for each of A alphas, M voxels, and B bootstrap samples.</dd>
<dt><strong><code>valinds</code></strong> :&ensp;<code>array_like, shape (TH, B)</code></dt>
<dd>The indices of the training data that were used as "validation" for each bootstrap sample.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bootstrap_ridge(
        X_train, y_train, X_test, y_test, alphas, nboots, chunklen, nchunks,
        corrmin=0.2, joined=None, singcutoff=1e-10, single_alpha=False,
        use_corr=True, return_wt=True, logger=ridge_logger, decrease_alpha: int = 0):
    &#34;&#34;&#34;Uses ridge regression with a bootstrapped held-out set to get optimal alpha values for each response.

    First, [nchunks] random chunks of length [chunklen] will be taken from [X_train] and [y_train] for each regression
    run.  [nboots] total regression runs will be performed.  The best alpha value for each response will be
    averaged across the bootstraps to estimate the best alpha for that response.

    If [joined] is given, it should be a list of lists where the STRFs for all the voxels in each sublist 
    will be given the same regularization parameter (the one that is the best on average).

    Parameters
    ----------
    X_train : array_like, shape (n_train, n_features)
    X_test : array_like, shape (n_test, n_features)
    y_train : array_like, shape (n_train, n_targets)
    y_test : array_like, shape (n_test, n_targets)
    alphas : list or array_like, shape (A,)
        Ridge parameters that will be tested. Should probably be log-spaced. np.logspace(0, 3, 20) works well.
    nboots : int
        The number of bootstrap samples to run. 15 to 30 works well.
    chunklen : int
        On each sample, the training data is broken into chunks of this length. This should be a few times 
        longer than your delay/STRF. e.g. for a STRF with 3 delays, I use chunks of length 10.
    nchunks : int
        The number of training chunks held out to test ridge parameters for each bootstrap sample. The product
        of nchunks and chunklen is the total number of training samples held out for each sample, and this 
        product should be about 20 percent of the total length of the training data.
    corrmin : float in [0..1], default 0.2
        Purely for display purposes. After each alpha is tested for each bootstrap sample, the number of 
        responses with correlation greater than this value will be printed. For long-running regressions this
        can give a rough sense of how well the model works before it&#39;s done.
    joined : None or list of array_like indices, default None
        If you want the STRFs for two (or more) responses to be directly comparable, you need to ensure that
        the regularization parameter that they use is the same. To do that, supply a list of the response sets
        that should use the same ridge parameter here. For example, if you have four responses, joined could
        be [np.array([0,1]), np.array([2,3])], in which case responses 0 and 1 will use the same ridge parameter
        (which will be parameter that is best on average for those two), and likewise for responses 2 and 3.
    singcutoff : float, default 1e-10
        The first step in ridge regression is computing the singular value decomposition (SVD) of the
        stimulus Rstim. If Rstim is not full rank, some singular values will be approximately equal
        to zero and the corresponding singular vectors will be noise. These singular values/vectors
        should be removed both for speed (the fewer multiplications the better!) and accuracy. Any
        singular values less than singcutoff will be removed.
    single_alpha : boolean, default False
        Whether to use a single alpha for all responses. Good for identification/decoding.
    use_corr : boolean, default True
        If True, this function will use correlation as its metric of model fit. If False, this function
        will instead use variance explained (R-squared) as its metric of model fit. For ridge regression
        this can make a big difference -- highly regularized solutions will have very small norms and
        will thus explain very little variance while still leading to high correlations, as correlation
        is scale-free while R**2 is not.
    return_wt : boolean, default True
        If True, this function will compute and return the regression weights after finding the best
        alpha parameter for each voxel. However, for very large models this can lead to memory issues.
        If false, this function will _not_ compute weights, but will still compute prediction performance
        on the prediction dataset (Pstim, Presp).

    Returns
    -------
    wt : array_like, shape (N, M)
        If [return_wt] is True, regression weights for N features and M responses. If [return_wt] is False, [].
    corrs : array_like, shape (M,)
        Validation set correlations. Predicted responses for the validation set are obtained using the regression
        weights: pred = np.dot(Pstim, wt), and then the correlation between each predicted response and each 
        column in Presp is found.
    alphas : array_like, shape (M,)
        The regularization coefficient (alpha) selected for each voxel using bootstrap cross-validation.
    bootstrap_corrs : array_like, shape (A, M, B)
        Correlation between predicted and actual responses on randomly held out portions of the training set,
        for each of A alphas, M voxels, and B bootstrap samples.
    valinds : array_like, shape (TH, B)
        The indices of the training data that were used as &#34;validation&#34; for each bootstrap sample.
    &#34;&#34;&#34;
    n_train, n_targets = y_train.shape
    splits = _gen_temporal_chunk_splits(
        nboots, n_train, chunklen, nchunks)
    valinds = [splits[1] for splits in splits]

    correlation_matrices = []
    for idx_bootstrap in _counter(range(nboots), countevery=1, total=nboots):
        logger.debug(&#34;Selecting held-out test set..&#34;)

        # get indices for training / testing
        train_indexes_, tune_indexes_ = splits[idx_bootstrap]

        # Select data
        X_train_ = X_train[train_indexes_, :]
        X_tune_ = X_train[tune_indexes_, :]
        y_train_ = y_train[train_indexes_, :]
        y_tune_ = y_train[tune_indexes_, :]

        # Run ridge regression using this test set
        correlation_matrix_ = _ridge_correlations_per_voxel_per_alpha(
            X_train_, X_tune_, y_train_, y_tune_, alphas,
            corrmin=corrmin, singcutoff=singcutoff,
            use_corr=use_corr,
            logger=logger)
        correlation_matrices.append(correlation_matrix_)

    # Find best alphas
    if nboots &gt; 0:
        all_correlation_matrices = np.dstack(correlation_matrices)
    else:
        all_correlation_matrices = None

    if not single_alpha:
        if nboots == 0:
            raise ValueError(&#34;You must run at least one cross-validation step to assign &#34;
                             &#34;different alphas to each response.&#34;)

        logger.info(&#34;Finding best alpha for each voxel..&#34;)
        if joined is None:
            # Find best alpha for each voxel
            meanbootcorrs = all_correlation_matrices.mean(2)
            bestalphainds = np.argmax(meanbootcorrs, 0)

            # decrease inds by one clipped at max index
            if decrease_alpha &gt; 0:
                print(&#39;decrease alpha mean&#39;, np.mean(bestalphainds))
                bestalphainds = np.clip(
                    bestalphainds - decrease_alpha, 0, len(alphas)-1)
                print(&#39;decrease alpha mean&#39;, np.mean(bestalphainds))
            valphas = alphas[bestalphainds]

        else:
            # Find best alpha for each group of voxels
            valphas = np.zeros((n_targets,))
            for jl in joined:
                # Mean across voxels in the set, then mean across bootstraps
                jcorrs = all_correlation_matrices[:, jl, :].mean(1).mean(1)
                bestalpha = np.argmax(jcorrs)
                valphas[jl] = alphas[bestalpha]
    else:
        logger.debug(&#34;Finding single best alpha..&#34;)
        if nboots == 0:
            if len(alphas) == 1:
                bestalphaind = 0
                bestalpha = alphas[0]
            else:
                raise ValueError(&#34;You must run at least one cross-validation step &#34;
                                 &#34;to choose best overall alpha, or only supply one&#34;
                                 &#34;possible alpha value.&#34;)
        else:
            meanbootcorr = all_correlation_matrices.mean(2).mean(1)
            bestalphaind = np.argmax(meanbootcorr)
            bestalpha = alphas[bestalphaind]

        valphas = np.array([bestalpha]*n_targets)
        logger.debug(&#34;Best alpha = %0.3f&#34; % bestalpha)

    if return_wt:
        # Find weights
        logger.debug(
            &#34;Computing weights for each response using entire training set..&#34;)
        # wt = _ridge_sklearn(X_train, y_train, valphas)
        wt = _ridge(X_train, y_train, valphas, singcutoff=singcutoff)

        # Predict responses on prediction set
        logger.debug(&#34;Predicting responses for predictions set..&#34;)
        pred = np.dot(X_test, wt)

        # Find prediction correlations
        nnpred = np.nan_to_num(pred)
        if use_corr:
            corrs_test = np.nan_to_num(np.array([np.corrcoef(y_test[:, ii], nnpred[:, ii].ravel())[0, 1]
                                                 for ii in range(y_test.shape[1])]))
        else:
            residual_variance = (y_test-pred).var(0)
            residual_sum_of_squares = 1 - \
                (residual_variance / y_test.var(0))
            corrs_test = np.sqrt(np.abs(residual_sum_of_squares)) * \
                np.sign(residual_sum_of_squares)

        return wt, corrs_test, valphas, all_correlation_matrices, valinds
    else:
        # get correlations for prediction dataset directly
        corrs_test = _ridge_correlations_per_voxel(
            X_train, X_test, y_train, X_test, valphas,
            use_corr=use_corr, logger=logger, singcutoff=singcutoff)

        return [], corrs_test, valphas, all_correlation_matrices, valinds</code></pre>
</details>
</dd>
<dt id="imodels.algebraic.ridge_multi.lowrank_ridge"><code class="name flex">
<span>def <span class="ident">lowrank_ridge</span></span>(<span>X, Y, alpha, r)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform ridge regression with many inputs and outputs using a rank-r approximation.</p>
<p>Parameters:
X : numpy.ndarray
Input features matrix of shape (n_samples, n_features).
Y : numpy.ndarray
Output targets matrix of shape (n_samples, n_outputs).
alpha : float
Regularization parameter (alphaa).
r : int
Rank for the truncated SVD.</p>
<p>Returns:
B : numpy.ndarray
Coefficient matrix of shape (n_features, n_outputs).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lowrank_ridge(X, Y, alpha, r):
    &#34;&#34;&#34;
    Perform ridge regression with many inputs and outputs using a rank-r approximation.

    Parameters:
    X : numpy.ndarray
        Input features matrix of shape (n_samples, n_features).
    Y : numpy.ndarray
        Output targets matrix of shape (n_samples, n_outputs).
    alpha : float
        Regularization parameter (alphaa).
    r : int
        Rank for the truncated SVD.

    Returns:
    B : numpy.ndarray
        Coefficient matrix of shape (n_features, n_outputs).
    &#34;&#34;&#34;
    # Step 1: Compute truncated SVD of X
    U_r, Sigma_r, V_r_T = randomized_svd(X, n_components=r)

    # Step 2: Compute T = U_r^T Y
    T = U_r.T @ Y  # Shape: (r, n_outputs)

    # Step 3: Compute D = (Σ_r^2 + λ I_r)^{-1} Σ_r
    denom = Sigma_r ** 2 + alpha
    D = Sigma_r / denom  # Shape: (r,)

    # Step 4: Compute B ≈ V_r D T
    DT = D[:, np.newaxis] * T  # Element-wise multiplication
    B = V_r_T.T @ DT  # Shape: (n_features, n_outputs)

    return B</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index 🔍</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="imodels.algebraic" href="index.html">imodels.algebraic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="imodels.algebraic.ridge_multi.boostrap_ridge_with_lowrank" href="#imodels.algebraic.ridge_multi.boostrap_ridge_with_lowrank">boostrap_ridge_with_lowrank</a></code></li>
<li><code><a title="imodels.algebraic.ridge_multi.bootstrap_low_rank_ridge" href="#imodels.algebraic.ridge_multi.bootstrap_low_rank_ridge">bootstrap_low_rank_ridge</a></code></li>
<li><code><a title="imodels.algebraic.ridge_multi.bootstrap_ridge" href="#imodels.algebraic.ridge_multi.bootstrap_ridge">bootstrap_ridge</a></code></li>
<li><code><a title="imodels.algebraic.ridge_multi.lowrank_ridge" href="#imodels.algebraic.ridge_multi.lowrank_ridge">lowrank_ridge</a></code></li>
</ul>
</li>
</ul>
<p><img align="center" width=100% src="https://csinva.io/imodels/img/anim.gif"> </img></p>
<!-- add wave animation -->
</nav>
</main>
<footer id="footer">
</footer>
</body>
</html>
<!-- add github corner -->
<a href="https://github.com/csinva/imodels" class="github-corner" aria-label="View source on GitHub"><svg width="120" height="120" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="m128.3,109.0 c113.8,99.7 119.0,89.6 119.0,89.6 c122.0,82.7 120.5,78.6 120.5,78.6 c119.2,72.0 123.4,76.3 123.4,76.3 c127.3,80.9 125.5,87.3 125.5,87.3 c122.9,97.6 130.6,101.9 134.4,103.2" fill="currentcolor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- add wave animation stylesheet -->
<link rel="stylesheet" href="github.css">
